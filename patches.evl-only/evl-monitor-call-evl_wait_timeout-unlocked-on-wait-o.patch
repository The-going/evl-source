From 2024e5c89e083ba9d311246624e5504ff8bdf066 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Wed, 9 Oct 2019 15:58:30 +0200
Subject: [PATCH] evl/monitor: call evl_wait_timeout() unlocked on wait op

---
 kernel/evl/monitor.c | 20 ++++++++++++--------
 1 file changed, 12 insertions(+), 8 deletions(-)

diff --git a/kernel/evl/monitor.c b/kernel/evl/monitor.c
index 616beda838c7..ab8c9a3115bf 100644
--- a/kernel/evl/monitor.c
+++ b/kernel/evl/monitor.c
@@ -325,17 +325,21 @@ static int wait_monitor_ungated(struct file *filp,
 
 	switch (event->protocol) {
 	case EVL_EVENT_COUNT:
-		xnlock_get_irqsave(&nklock, flags);
-		if (atomic_dec_return(&state->u.event.value) < 0) {
-			if (filp->f_flags & O_NONBLOCK)
+		if (filp->f_flags & O_NONBLOCK) {
+			if (atomic_dec_return(&state->u.event.value) < 0)
 				ret = -EAGAIN;
-			else
-				ret = evl_wait_timeout(&event->wait_queue,
+		} else {
+			xnlock_get_irqsave(&nklock, flags);
+			if (atomic_dec_return(&state->u.event.value) < 0) {
+				evl_add_wait_queue(&event->wait_queue,
 						timeout, tmode);
-			if (ret) /* Rollback decrement if failed. */
-				atomic_inc(&state->u.event.value);
+				xnlock_put_irqrestore(&nklock, flags);
+				ret = evl_wait_schedule();
+				if (ret) /* Rollback decrement if failed. */
+					atomic_inc(&state->u.event.value);
+			} else
+				xnlock_put_irqrestore(&nklock, flags);
 		}
-		xnlock_put_irqrestore(&nklock, flags);
 		break;
 	case EVL_EVENT_MASK:
 		if (filp->f_flags & O_NONBLOCK)
-- 
2.16.4

