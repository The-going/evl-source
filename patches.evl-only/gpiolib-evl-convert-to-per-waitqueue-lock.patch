From 543dc03e69947f18d9d16ab1564ce5414e702fa1 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Wed, 23 Oct 2019 12:05:12 +0200
Subject: [PATCH] gpiolib: evl: convert to per-waitqueue lock

---
 drivers/gpio/gpiolib.c | 24 +++++++-----------------
 1 file changed, 7 insertions(+), 17 deletions(-)

diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index 43fc44feff4b..4640b7332a7b 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -954,28 +954,19 @@ static irqreturn_t lineevent_oob_irq_handler(int irq, void *p)
 {
 	struct lineevent_state *le = p;
 	struct gpioevent_data ge;
-	unsigned long flags;
 
 	ge.timestamp = evl_ktime_monotonic();
 
 	if (lineevent_read_pin(le, &ge, false) == IRQ_NONE)
 		return IRQ_NONE;
 
-	raw_spin_lock_irqsave(&le->oob_state.lock, flags);
-
-	/*
-	 * XXX: evl_wait_queue services still serialize on the ugly
-	 * big lock, so we need to grab it here until we get rid of
-	 * it in the EVL core.
-	 */
-	xnlock_get(&nklock);
+	evl_spin_lock(&le->oob_state.wait.lock);
 	kfifo_put(&le->events, ge);
 	evl_wake_up_head(&le->oob_state.wait);
-	xnlock_put(&nklock);
-
 	evl_signal_poll_events(&le->oob_state.poll_head, POLLIN|POLLRDNORM);
+	evl_spin_unlock(&le->oob_state.wait.lock);
 
-	raw_spin_unlock_irqrestore(&le->oob_state.lock, flags);
+	evl_schedule();
 
 	return IRQ_HANDLED;
 }
@@ -989,12 +980,12 @@ static __poll_t lineevent_oob_poll(struct file *filep,
 
 	evl_poll_watch(&le->oob_state.poll_head, wait, NULL);
 
-	xnlock_get_irqsave(&nklock, flags);
+	evl_spin_lock_irqsave(&le->oob_state.wait.lock, flags);
 
 	if (!kfifo_is_empty(&le->events))
 		ready |= POLLIN|POLLRDNORM;
 
-	xnlock_put_irqrestore(&nklock, flags);
+	evl_spin_unlock_irqrestore(&le->oob_state.wait.lock, flags);
 
 	return ready;
 }
@@ -1015,7 +1006,7 @@ static ssize_t lineevent_oob_read(struct file *filep,
 		return -EPERM;
 
 	do {
-		raw_spin_lock_irqsave(&le->oob_state.lock, flags);
+		evl_spin_lock_irqsave(&le->oob_state.wait.lock, flags);
 
 		ret = kfifo_get(&le->events, &ge);
 		/*
@@ -1025,7 +1016,7 @@ static ssize_t lineevent_oob_read(struct file *filep,
 		if (!ret)
 			ret = 0;
 
-		raw_spin_unlock_irqrestore(&le->oob_state.lock, flags);
+		evl_spin_unlock_irqrestore(&le->oob_state.wait.lock, flags);
 
 		if (ret) {
 			ret = raw_copy_to_user(buf, &ge, sizeof(ge));
@@ -1047,7 +1038,6 @@ static int lineevent_init_oob_state(struct lineevent_state *le,
 {
 	evl_init_wait(&le->oob_state.wait, &evl_mono_clock, EVL_WAIT_PRIO);
 	evl_init_poll_head(&le->oob_state.poll_head);
-	raw_spin_lock_init(&le->oob_state.lock);
 
 	return request_irq(le->irq,
 			lineevent_oob_irq_handler,
-- 
2.16.4

