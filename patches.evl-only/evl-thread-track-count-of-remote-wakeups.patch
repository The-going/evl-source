From f1b35535cd067b15f0cc3656ecae643637d663b9 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Fri, 2 Aug 2019 15:43:10 +0200
Subject: [PATCH] evl/thread: track count of remote wakeups

Having to trigger a rescheduling on a remote CPU for waking up an EVL
thread may be the sign of a misconfiguration.

Track the number of times this happens on a per-thread basis and
export this information via /sysfs and EVL_THRIOC_GET_STATE.
---
 include/evl/thread.h       | 1 +
 include/uapi/evl/control.h | 2 +-
 include/uapi/evl/thread.h  | 1 +
 kernel/evl/thread.c        | 8 +++++++-
 4 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/include/evl/thread.h b/include/evl/thread.h
index 16422518967..5ad467cd72b 100644
--- a/include/evl/thread.h
+++ b/include/evl/thread.h
@@ -119,6 +119,7 @@ struct evl_thread {
 		struct evl_counter isw;	/* in-band switches */
 		struct evl_counter csw;	/* context switches */
 		struct evl_counter sc;	/* OOB syscalls */
+		struct evl_counter rwa;	/* remote wakeups */
 		struct evl_counter pf;	/* Number of page faults */
 		struct evl_account account; /* Execution time accounting entity */
 		struct evl_account lastperiod; /* Interval marker for execution time reports */
diff --git a/include/uapi/evl/control.h b/include/uapi/evl/control.h
index bfedf4287fd..42fdca08aec 100644
--- a/include/uapi/evl/control.h
+++ b/include/uapi/evl/control.h
@@ -10,7 +10,7 @@
 #include <linux/types.h>
 #include <uapi/evl/sched.h>
 
-#define EVL_ABI_LEVEL  9
+#define EVL_ABI_LEVEL  10
 
 #define EVL_CONTROL_DEV  "/dev/evl/control"
 
diff --git a/include/uapi/evl/thread.h b/include/uapi/evl/thread.h
index f75b07542fa..da7f0f985cf 100644
--- a/include/uapi/evl/thread.h
+++ b/include/uapi/evl/thread.h
@@ -87,6 +87,7 @@ struct evl_thread_state {
 	__u32 isw;
 	__u32 csw;
 	__u32 sc;
+	__u32 rwa;
 	__u64 xtime;
 };
 
diff --git a/kernel/evl/thread.c b/kernel/evl/thread.c
index b1a4df1a56f..68337d5a036 100644
--- a/kernel/evl/thread.c
+++ b/kernel/evl/thread.c
@@ -546,6 +546,8 @@ bool evl_wakeup_thread(struct evl_thread *thread, int mask, int info)
 			evl_enqueue_thread(thread);
 			thread->state |= T_READY;
 			evl_set_resched(rq);
+			if (rq != this_evl_rq())
+				evl_inc_counter(&thread->stat.rwa);
 		}
 	}
 
@@ -645,6 +647,8 @@ void evl_release_thread(struct evl_thread *thread, int mask, int info)
 ready:
 	thread->state |= T_READY;
 	evl_set_resched(rq);
+	if (rq != this_evl_rq())
+		evl_inc_counter(&thread->stat.rwa);
 out:
 	xnlock_put_irqrestore(&nklock, flags);
 
@@ -2019,6 +2023,7 @@ void evl_get_thread_state(struct evl_thread *thread,
 	statebuf->isw = evl_get_counter(&thread->stat.isw);
 	statebuf->csw = evl_get_counter(&thread->stat.csw);
 	statebuf->sc = evl_get_counter(&thread->stat.sc);
+	statebuf->rwa = evl_get_counter(&thread->stat.rwa);
 	statebuf->xtime = ktime_to_ns(evl_get_account_total(
 					&thread->stat.account));
 	xnlock_put_irqrestore(&nklock, flags);
@@ -2417,10 +2422,11 @@ static ssize_t stats_show(struct device *dev,
 	} else
 		usage = 0;
 
-	ret = snprintf(buf, PAGE_SIZE, "%lu %lu %lu %Lu %d\n",
+	ret = snprintf(buf, PAGE_SIZE, "%lu %lu %lu %lu %Lu %d\n",
 		thread->stat.isw.counter,
 		thread->stat.csw.counter,
 		thread->stat.sc.counter,
+		thread->stat.rwa.counter,
 		ktime_to_ns(thread->stat.account.total),
 		usage);
 
-- 
2.16.4

