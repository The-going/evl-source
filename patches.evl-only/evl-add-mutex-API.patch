From 22e32ecf160d966121c3b208db27636ae8b3e583 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Thu, 24 Jan 2019 19:25:00 +0100
Subject: [PATCH] evl: add mutex API

---
 include/evenless/mutex.h | 19 +++++++++++++
 kernel/evenless/Makefile |  1 +
 kernel/evenless/mutex.c  | 71 ++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 91 insertions(+)
 create mode 100644 include/evenless/mutex.h
 create mode 100644 kernel/evenless/mutex.c

diff --git a/include/evenless/mutex.h b/include/evenless/mutex.h
new file mode 100644
index 00000000000..08438468dcf
--- /dev/null
+++ b/include/evenless/mutex.h
@@ -0,0 +1,19 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2019 Philippe Gerum  <rpm@xenomai.org>
+ */
+
+#ifndef _EVENLESS_MUTEX_H
+#define _EVENLESS_MUTEX_H
+
+#include <linux/ktime.h>
+#include <linux/atomic.h>
+#include <evenless/synch.h>
+
+struct evl_mutex {
+	struct evl_syn wait_queue;
+	atomic_t fastlock;
+};
+
+#endif /* !_EVENLESS_MUTEX_H */
diff --git a/kernel/evenless/Makefile b/kernel/evenless/Makefile
index 528cd3cfaf0..b98e338fb63 100644
--- a/kernel/evenless/Makefile
+++ b/kernel/evenless/Makefile
@@ -15,6 +15,7 @@ evenless-y :=		\
 	mapper.o	\
 	memory.o	\
 	monitor.o	\
+	mutex.o		\
 	poller.o	\
 	sem.o		\
 	synch.o		\
diff --git a/kernel/evenless/mutex.c b/kernel/evenless/mutex.c
new file mode 100644
index 00000000000..9e489c7be49
--- /dev/null
+++ b/kernel/evenless/mutex.c
@@ -0,0 +1,71 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2019 Philippe Gerum  <rpm@xenomai.org>
+ */
+
+#include <evenless/timer.h>
+#include <evenless/synch.h>
+#include <evenless/clock.h>
+#include <evenless/sched.h>
+#include <evenless/thread.h>
+#include <evenless/mutex.h>
+
+void evl_init_mutex(struct evl_mutex *mutex)
+{
+	evl_init_syn(&mutex->wait_queue, EVL_SYN_PI,
+		     &evl_mono_clock, &mutex->fastlock);
+}
+EXPORT_SYMBOL_GPL(evl_init_mutex);
+
+void evl_destroy_mutex(struct evl_mutex *mutex)
+{
+	evl_destroy_syn(&mutex->wait_queue);
+}
+EXPORT_SYMBOL_GPL(evl_destroy_mutex);
+
+static int lock_timeout(struct evl_mutex *mutex, ktime_t timeout,
+			enum evl_tmode timeout_mode)
+{
+	int ret;
+
+	ret = evl_try_acquire_syn(&mutex->wait_queue);
+	if (ret != -EBUSY)
+		return ret;
+
+	if (timeout_nonblock(timeout))
+		return -EWOULDBLOCK;
+
+	for (;;) {
+		ret = evl_acquire_syn(&mutex->wait_queue, timeout, timeout_mode);
+		if (ret == 0)
+			break;
+		if (ret & T_BREAK)
+			continue;
+		ret = ret & T_TIMEO ? -ETIMEDOUT : -EIDRM;
+		break;
+	}
+
+	return ret;
+}
+
+int evl_lock_timeout(struct evl_mutex *mutex, ktime_t timeout)
+{
+	return lock_timeout(mutex, timeout, EVL_ABS);
+}
+EXPORT_SYMBOL_GPL(evl_lock_timeout);
+
+int evl_lock(struct evl_mutex *mutex)
+{
+	return lock_timeout(mutex, EVL_INFINITE, EVL_REL);
+}
+EXPORT_SYMBOL_GPL(evl_lock);
+
+void evl_unlock(struct evl_mutex *mutex)
+{
+	struct evl_thread *curr = evl_current_thread();
+
+	if (evl_release_syn(&mutex->wait_queue, curr))
+		evl_schedule();
+}
+EXPORT_SYMBOL_GPL(evl_unlock);
-- 
2.16.4

