From 1123e5091ec4c4675b5ef7c036ca792c452cce57 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Wed, 6 Feb 2019 15:17:32 +0100
Subject: [PATCH] evl/monitor: add timeout to gate lock operation

---
 include/uapi/evenless/monitor.h |  6 ++++-
 kernel/evenless/monitor.c       | 50 ++++++++++++++++++++++++++++++-----------
 2 files changed, 42 insertions(+), 14 deletions(-)

diff --git a/include/uapi/evenless/monitor.h b/include/uapi/evenless/monitor.h
index b4ace605805..5733b5a8733 100644
--- a/include/uapi/evenless/monitor.h
+++ b/include/uapi/evenless/monitor.h
@@ -38,6 +38,10 @@ struct evl_monitor_state {
 	} u;
 };
 
+struct evl_monitor_lockreq {
+	struct timespec timeout;
+};
+
 struct evl_monitor_waitreq {
 	struct timespec timeout;
 	__u32 gatefd;
@@ -55,7 +59,7 @@ struct evl_monitor_binding {
 
 #define EVL_MONITOR_IOCBASE	'm'
 
-#define EVL_MONIOC_ENTER	_IO(EVL_MONITOR_IOCBASE, 0)
+#define EVL_MONIOC_ENTER	_IOW(EVL_MONITOR_IOCBASE, 0, struct evl_monitor_lockreq)
 #define EVL_MONIOC_EXIT		_IO(EVL_MONITOR_IOCBASE, 1)
 #define EVL_MONIOC_WAIT		_IOWR(EVL_MONITOR_IOCBASE, 2, struct evl_monitor_waitreq)
 #define EVL_MONIOC_UNWAIT	_IOWR(EVL_MONITOR_IOCBASE, 3, struct evl_monitor_unwaitreq)
diff --git a/kernel/evenless/monitor.c b/kernel/evenless/monitor.c
index 105220c4aa0..01a4760bcaf 100644
--- a/kernel/evenless/monitor.c
+++ b/kernel/evenless/monitor.c
@@ -164,21 +164,34 @@ static void wakeup_waiters(struct evl_monitor *event)
 }
 
 /* nklock held, irqs off */
-static int __enter_monitor(struct evl_monitor *gate)
+static int __enter_monitor(struct evl_monitor *gate,
+			struct evl_monitor_lockreq *req)
 {
+	ktime_t timeout = EVL_INFINITE;
+	enum evl_tmode tmode;
 	int info;
 
 	evl_commit_monitor_ceiling();
 
-	info = evl_lock_mutex(&gate->lock);
-	if (info)
-		/* Break or error, no timeout possible. */
-		return info & T_BREAK ? -EINTR : -EINVAL;
+	if (req) {
+		if ((unsigned long)req->timeout.tv_nsec >= ONE_BILLION)
+			return -EINVAL;
+		timeout = timespec_to_ktime(req->timeout);
+	}
+
+	tmode = timeout ? EVL_ABS : EVL_REL;
+	info = evl_lock_mutex_timeout(&gate->lock, timeout, tmode);
+	if (info) {
+		if (info & T_BREAK)
+			return -EINTR;
+		return info & T_TIMEO ? -EAGAIN : -EINVAL;
+	}
 
 	return 0;
 }
 
-static int enter_monitor(struct evl_monitor *gate)
+static int enter_monitor(struct evl_monitor *gate,
+			struct evl_monitor_lockreq *req)
 {
 	struct evl_thread *curr = evl_current();
 	unsigned long flags;
@@ -188,10 +201,10 @@ static int enter_monitor(struct evl_monitor *gate)
 		return -EINVAL;
 
 	if (evl_is_mutex_owner(gate->lock.fastlock, fundle_of(curr)))
-		return -EDEADLK;	/* Deny recursive locking. */
+		return -EDEADLK; /* Deny recursive locking. */
 
 	xnlock_get_irqsave(&nklock, flags);
-	ret = __enter_monitor(gate);
+	ret = __enter_monitor(gate, req);
 	xnlock_put_irqrestore(&nklock, flags);
 
 	return ret;
@@ -276,6 +289,11 @@ static int wait_monitor(struct evl_monitor *event,
 		goto out;
 	}
 
+	if ((unsigned long)req->timeout.tv_nsec >= ONE_BILLION) {
+		op_ret = -EINVAL;
+		goto out;
+	}
+
 	/* Find the gate monitor protecting us. */
 	gate = get_monitor_by_fd(req->gatefd, &sfilp);
 	if (gate == NULL) {
@@ -334,7 +352,7 @@ static int wait_monitor(struct evl_monitor *event,
 			op_ret = -ETIMEDOUT;
 	}
 
-	ret = __enter_monitor(gate);
+	ret = __enter_monitor(gate, NULL);
 
 	untrack_event(event, gate);
 unlock:
@@ -363,7 +381,7 @@ static int unwait_monitor(struct evl_monitor *event,
 	if (gate == NULL)
 		return -EINVAL;
 
-	ret = enter_monitor(gate);
+	ret = enter_monitor(gate, NULL);
 	if (ret == 0) {
 		xnlock_get_irqsave(&nklock, flags);
 		untrack_event(event, gate);
@@ -399,6 +417,7 @@ static long monitor_oob_ioctl(struct file *filp, unsigned int cmd,
 	struct evl_monitor *mon = element_of(filp, struct evl_monitor);
 	struct evl_monitor_unwaitreq uwreq, __user *u_uwreq;
 	struct evl_monitor_waitreq wreq, __user *u_wreq;
+	struct evl_monitor_lockreq lreq, __user *u_lreq;
 	__s32 op_ret;
 	long ret;
 
@@ -410,7 +429,9 @@ static long monitor_oob_ioctl(struct file *filp, unsigned int cmd,
 		ret = wait_monitor(mon, &wreq, &op_ret);
 		raw_put_user(op_ret, &u_wreq->status);
 		return ret;
-	} else if (cmd == EVL_MONIOC_UNWAIT) {
+	}
+
+	if (cmd == EVL_MONIOC_UNWAIT) {
 		u_uwreq = (typeof(u_uwreq))arg;
 		ret = raw_copy_from_user(&uwreq, u_uwreq, sizeof(uwreq));
 		if (ret)
@@ -420,7 +441,11 @@ static long monitor_oob_ioctl(struct file *filp, unsigned int cmd,
 
 	switch (cmd) {
 	case EVL_MONIOC_ENTER:
-		ret = enter_monitor(mon);
+		u_lreq = (typeof(u_lreq))arg;
+		ret = raw_copy_from_user(&lreq, u_lreq, sizeof(lreq));
+		if (ret)
+			return -EFAULT;
+		ret = enter_monitor(mon, &lreq);
 		break;
 	case EVL_MONIOC_EXIT:
 		ret = exit_monitor(mon);
@@ -429,7 +454,6 @@ static long monitor_oob_ioctl(struct file *filp, unsigned int cmd,
 		ret = -ENOTTY;
 	}
 
-
 	return ret;
 }
 
-- 
2.16.4

