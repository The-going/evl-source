From 8576a8ea0015802edd625066af38e361ea87f1fb Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Fri, 26 Jul 2019 21:41:56 +0200
Subject: [PATCH] evl/clock: reinstate fast forward on tick overrun

This is still beneficial in some scenarii which have been observed
lately, and may come for (almost) free with a proper placement of
the clock reading calls.
---
 kernel/evl/clock.c | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/kernel/evl/clock.c b/kernel/evl/clock.c
index 3344dbe2bd2..8cc4320a957 100644
--- a/kernel/evl/clock.c
+++ b/kernel/evl/clock.c
@@ -296,9 +296,9 @@ static void do_clock_tick(struct evl_clock *clock, struct evl_timerbase *tmb)
 	 */
 	rq->lflags |= RQ_TIMER;
 
+	now = evl_read_clock(clock);
 	while ((tn = evl_get_tqueue_head(tq)) != NULL) {
 		timer = container_of(tn, struct evl_timer, node);
-		now = evl_read_clock(clock);
 		if (now < evl_tdate(timer))
 			break;
 
@@ -320,11 +320,14 @@ static void do_clock_tick(struct evl_clock *clock, struct evl_timerbase *tmb)
 
 		raw_spin_unlock(&tmb->lock);
 		timer->handler(timer);
+		now = evl_read_clock(clock);
 		raw_spin_lock(&tmb->lock);
 
 		if (timer_needs_enqueuing(timer)) {
-			timer->periodic_ticks++;
-			evl_update_timer_date(timer);
+			do {
+				timer->periodic_ticks++;
+				evl_update_timer_date(timer);
+			} while (evl_tdate(timer) < now);
 			if (likely(evl_timer_on_rq(timer, rq)))
 				evl_enqueue_timer(timer, tq);
 		}
-- 
2.16.4

