From 139f56376a507c991fa45bb7086be10e05b6186f Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Sun, 27 Oct 2019 17:47:39 +0100
Subject: [PATCH] evl/thread: close race in demotion process

Prevent a rescheduling upon IRQ from keeping a demoted thread alive on
a CPU in oob mode. i.e.

CPU0:

evl_kick_thread(t)
   IRQ -> evl_schedule()
      ... t resumed and spinning in oob mode ...

switch to SCHED_WEAK never applied to t.
---
 kernel/evl/thread.c | 21 ++++++++-------------
 1 file changed, 8 insertions(+), 13 deletions(-)

diff --git a/kernel/evl/thread.c b/kernel/evl/thread.c
index d4de8196f529..48f8562ac76c 100644
--- a/kernel/evl/thread.c
+++ b/kernel/evl/thread.c
@@ -1437,23 +1437,15 @@ void evl_demote_thread(struct evl_thread *thread)
 
 	no_ugly_lock();
 
-	/*
-	 * First we kick the thread out of oob context, and have it
-	 * resume execution immediately on the in-band stage.
-	 */
-	evl_kick_thread(thread);
-
-	/* FIXME: this is racy if @thread can preempt us, need irqs off. */
-
 	evl_spin_lock_irqsave(&thread->lock, flags);
 	xnlock_get(&nklock);
 
 	/*
-	 * Then we demote it, turning that thread into a non real-time
-	 * EVL thread, which still has access to EVL resources, but
-	 * won't compete for real-time scheduling anymore. In effect,
-	 * moving the thread to a weak scheduling class/priority will
-	 * prevent it from sticking back to OOB context.
+	 * First demote @thread to the weak class, which still has
+	 * access to EVL resources, but won't compete for real-time
+	 * scheduling anymore. This will prevent @thread from keeping
+	 * the CPU busy in out-of-band context once kicked out from
+	 * wait.
 	 */
 	param.weak.prio = 0;
 	sched_class = &evl_sched_weak;
@@ -1461,6 +1453,9 @@ void evl_demote_thread(struct evl_thread *thread)
 
 	xnlock_put(&nklock);
 	evl_spin_unlock_irqrestore(&thread->lock, flags);
+
+	/* Then unblock it from any wait state. */
+	evl_kick_thread(thread);
 }
 EXPORT_SYMBOL_GPL(evl_demote_thread);
 
-- 
2.16.4

