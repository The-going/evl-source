From 12dcca5efa32a02938b4236a92cba52d5247d675 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Thu, 14 Feb 2019 10:44:13 +0100
Subject: [PATCH] evl/monitor: fix handling of evl_wait_timeout() status

---
 kernel/evenless/monitor.c | 26 ++++++++++++--------------
 1 file changed, 12 insertions(+), 14 deletions(-)

diff --git a/kernel/evenless/monitor.c b/kernel/evenless/monitor.c
index df16b74206d..caaf2b77c70 100644
--- a/kernel/evenless/monitor.c
+++ b/kernel/evenless/monitor.c
@@ -291,8 +291,8 @@ static int wait_monitor(struct evl_monitor *event,
 			__s32 *r_op_ret)
 {
 	struct evl_thread *curr = evl_current();
-	int ret = 0, op_ret = 0, info;
 	struct evl_monitor *gate;
+	int ret = 0, op_ret = 0;
 	struct evl_file *efilp;
 	enum evl_tmode tmode;
 	unsigned long flags;
@@ -329,9 +329,9 @@ static int wait_monitor(struct evl_monitor *event,
 	xnlock_get_irqsave(&nklock, flags);
 
 	/*
-	 * Track event monitors the gate monitor protects. When
-	 * multiple threads issue concurrent wait requests on the same
-	 * event monitor, they must use the same gate to serialize.
+	 * Track event monitors the gate protects. When multiple
+	 * threads issue concurrent wait requests on the same event
+	 * monitor, they must use the same gate to serialize.
 	 */
 	if (event->gate == NULL) {
 		list_add_tail(&event->next, &gate->events);
@@ -356,17 +356,15 @@ static int wait_monitor(struct evl_monitor *event,
 	 */
 	timeout = timespec_to_ktime(req->timeout);
 	tmode = timeout ? EVL_ABS : EVL_REL;
-	info = evl_wait_timeout(&event->wait_queue, timeout, tmode);
-	if (info) {
-		if (info & T_BREAK) {
-			ret = -EINTR;
-			goto unlock;
-		}
-		if (info & T_TIMEO)
-			op_ret = -ETIMEDOUT;
-	}
+	ret = evl_wait_timeout(&event->wait_queue, timeout, tmode);
+	if (ret == -EINTR)
+		goto unlock;
+
+	if (ret)
+		op_ret = ret;
 
-	ret = __enter_monitor(gate, NULL);
+	if (ret != -EIDRM)
+		ret = __enter_monitor(gate, NULL);
 
 	untrack_event(event, gate);
 unlock:
-- 
2.16.4

