From 51baa49392d4c4d995adc858686e365e57ec2564 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Thu, 7 Nov 2019 10:52:27 +0100
Subject: [PATCH] evl/sem: fix count leakage in non-blocking case

We need decrement-unless-zero-or-negative semantics in the
non-blocking case.
---
 kernel/evl/monitor.c | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/kernel/evl/monitor.c b/kernel/evl/monitor.c
index a98e49fb4224..f36a9e4c1175 100644
--- a/kernel/evl/monitor.c
+++ b/kernel/evl/monitor.c
@@ -319,27 +319,35 @@ static int wait_monitor_ungated(struct file *filp,
 	struct evl_monitor_state *state = event->state;
 	enum evl_tmode tmode;
 	unsigned long flags;
+	int ret = 0, val;
 	ktime_t timeout;
-	int ret = 0;
+	atomic_t *at;
 
 	timeout = timespec_to_ktime(req->timeout);
 	tmode = timeout ? EVL_ABS : EVL_REL;
 
 	switch (event->protocol) {
 	case EVL_EVENT_COUNT:
+		at = &state->u.event.value;
 		if (filp->f_flags & O_NONBLOCK) {
-			if (atomic_dec_return(&state->u.event.value) < 0)
-				ret = -EAGAIN;
+			val = atomic_read(at);
+			/* atomic_dec_unless_zero_or_negative */
+			do {
+				if (unlikely(val <= 0)) {
+					ret = -EAGAIN;
+					break;
+				}
+			} while (!atomic_try_cmpxchg(at, &val, val - 1));
 		} else {
 			evl_spin_lock_irqsave(&event->wait_queue.lock, flags);
-			if (atomic_dec_return(&state->u.event.value) < 0) {
+			if (atomic_dec_return(at) < 0) {
 				evl_add_wait_queue(&event->wait_queue,
 						timeout, tmode);
 				evl_spin_unlock_irqrestore(&event->wait_queue.lock,
 							flags);
 				ret = evl_wait_schedule(&event->wait_queue);
 				if (ret) /* Rollback decrement if failed. */
-					atomic_inc(&state->u.event.value);
+					atomic_inc(at);
 			} else
 				evl_spin_unlock_irqrestore(&event->wait_queue.lock,
 							flags);
-- 
2.16.4

