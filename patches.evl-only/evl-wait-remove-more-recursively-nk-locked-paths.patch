From 1bf8dc5d2ed5c5629fbcf6297308848aa637ea16 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Mon, 4 Feb 2019 16:09:55 +0100
Subject: [PATCH] evl/wait: remove more recursively (nk)locked paths

---
 include/evenless/wait.h   |  2 ++
 kernel/evenless/ksem.c    | 13 +++++++------
 kernel/evenless/monitor.c |  2 +-
 kernel/evenless/wait.c    | 22 ++++++++++++----------
 4 files changed, 22 insertions(+), 17 deletions(-)

diff --git a/include/evenless/wait.h b/include/evenless/wait.h
index d46f1cf6e5e..49da5e3d481 100644
--- a/include/evenless/wait.h
+++ b/include/evenless/wait.h
@@ -134,6 +134,8 @@ struct evl_thread *evl_wake_up_head(struct evl_wait_queue *wq)
 	return evl_wake_up(wq, NULL);
 }
 
+void evl_flush_wait_locked(struct evl_wait_queue *wq, int reason);
+
 void evl_flush_wait(struct evl_wait_queue *wq, int reason);
 
 void evl_abort_wait(struct evl_thread *thread,
diff --git a/kernel/evenless/ksem.c b/kernel/evenless/ksem.c
index 67c5b773bdc..6861623eea1 100644
--- a/kernel/evenless/ksem.c
+++ b/kernel/evenless/ksem.c
@@ -51,12 +51,13 @@ void evl_up(struct evl_ksem *sem)
 {
 	unsigned long flags;
 
-	if (evl_wake_up_head(&sem->wait_queue))
-		evl_schedule();
-	else {
-		xnlock_get_irqsave(&nklock, flags);
+	xnlock_get_irqsave(&nklock, flags);
+
+	if (!evl_wake_up_head(&sem->wait_queue))
 		sem->value++;
-		xnlock_put_irqrestore(&nklock, flags);
-	}
+
+	xnlock_put_irqrestore(&nklock, flags);
+
+	evl_schedule();
 }
 EXPORT_SYMBOL_GPL(evl_up);
diff --git a/kernel/evenless/monitor.c b/kernel/evenless/monitor.c
index 2000f4e099d..105220c4aa0 100644
--- a/kernel/evenless/monitor.c
+++ b/kernel/evenless/monitor.c
@@ -147,7 +147,7 @@ static void wakeup_waiters(struct evl_monitor *event)
 	if ((state->flags & EVL_MONITOR_SIGNALED) &&
 		evl_wait_active(&event->wait_queue)) {
 		if (bcast)
-			evl_flush_wait(&event->wait_queue, 0);
+			evl_flush_wait_locked(&event->wait_queue, 0);
 		else if (state->flags & EVL_MONITOR_TARGETED) {
 			evl_for_each_waiter_safe(waiter, n,
 						&event->wait_queue) {
diff --git a/kernel/evenless/wait.c b/kernel/evenless/wait.c
index 250ad02cd8c..62053948509 100644
--- a/kernel/evenless/wait.c
+++ b/kernel/evenless/wait.c
@@ -35,6 +35,7 @@ void evl_destroy_wait(struct evl_wait_queue *wq)
 }
 EXPORT_SYMBOL_GPL(evl_destroy_wait);
 
+/* nklock held, irqs off */
 void evl_add_wait_queue(struct evl_wait_queue *wq, ktime_t timeout,
 			enum evl_tmode timeout_mode)
 {
@@ -56,13 +57,10 @@ void evl_add_wait_queue(struct evl_wait_queue *wq, ktime_t timeout,
 }
 EXPORT_SYMBOL_GPL(evl_add_wait_queue);
 
+/* nklock held, irqs off */
 struct evl_thread *evl_wake_up(struct evl_wait_queue *wq,
 			struct evl_thread *waiter)
 {
-	unsigned long flags;
-
-	xnlock_get_irqsave(&nklock, flags);
-
 	trace_evl_wait_wakeup(wq);
 
 	if (list_empty(&wq->wait_list))
@@ -74,18 +72,14 @@ struct evl_thread *evl_wake_up(struct evl_wait_queue *wq,
 		evl_wakeup_thread(waiter, T_PEND, 0);
 	}
 
-	xnlock_put_irqrestore(&nklock, flags);
-
 	return waiter;
 }
 EXPORT_SYMBOL_GPL(evl_wake_up);
 
-void evl_flush_wait(struct evl_wait_queue *wq, int reason)
+/* nklock held, irqs off */
+void evl_flush_wait_locked(struct evl_wait_queue *wq, int reason)
 {
 	struct evl_thread *waiter, *tmp;
-	unsigned long flags;
-
-	xnlock_get_irqsave(&nklock, flags);
 
 	trace_evl_wait_flush(wq);
 
@@ -94,7 +88,15 @@ void evl_flush_wait(struct evl_wait_queue *wq, int reason)
 					&wq->wait_list, wait_next)
 			evl_wakeup_thread(waiter, T_PEND, reason);
 	}
+}
+EXPORT_SYMBOL_GPL(evl_flush_wait_locked);
 
+void evl_flush_wait(struct evl_wait_queue *wq, int reason)
+{
+	unsigned long flags;
+
+	xnlock_get_irqsave(&nklock, flags);
+	evl_flush_wait_locked(wq, reason);
 	xnlock_put_irqrestore(&nklock, flags);
 }
 EXPORT_SYMBOL_GPL(evl_flush_wait);
-- 
2.16.4

