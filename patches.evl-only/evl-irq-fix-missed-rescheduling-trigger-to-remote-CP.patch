From f80a4430d350bb6cfd881df1a833546d0963604d Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Mon, 4 Nov 2019 15:38:14 +0100
Subject: [PATCH] evl/irq: fix missed rescheduling trigger to remote CPU

Maybe counter-intuitively but for a good reason (i.e. lockless
operation), if a rescheduling signal was set pending by the local CPU
for a remote one, RQ_SCHED was raised into this_evl_rq()->local_flags,
not into this_evl_rq()->flags.

We need to check both values in the IRQ epilogue for detecting local,
self-directed and remote-targeted signals which may have been raised
while the local CPU was running the interrupt handler.

Remote-targeted signals are eventually passed to other CPUs via IPIs
by the local CPU when test_resched() runs (see __evl_schedule()).
---
 include/evl/irq.h | 7 +------
 1 file changed, 1 insertion(+), 6 deletions(-)

diff --git a/include/evl/irq.h b/include/evl/irq.h
index 8720c8969846..babee3738b4c 100644
--- a/include/evl/irq.h
+++ b/include/evl/irq.h
@@ -25,15 +25,10 @@ static inline void evl_exit_irq(void)
 	this_rq->local_flags &= ~RQ_IRQ;
 
 	/*
-	 * We are only interested in RQ_SCHED previously set by an OOB
-	 * handler on the current CPU, so there is no cache coherence
-	 * issue. Remote CPUs pair RQ_SCHED requests with an IPI, so
-	 * we don't care about missing them here.
-	 *
 	 * CAUTION: Switching stages as a result of rescheduling may
 	 * re-enable irqs, shut them off before returning if so.
 	 */
-	if (evl_need_resched(this_rq)) {
+	if ((this_rq->flags|this_rq->local_flags) & RQ_SCHED) {
 		evl_schedule();
 		if (!hard_irqs_disabled())
 			hard_local_irq_disable();
-- 
2.16.4

