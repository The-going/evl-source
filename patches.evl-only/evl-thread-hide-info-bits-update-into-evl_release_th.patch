From 34526142898e2f4903e486c6961b3115a91f896d Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Tue, 5 Feb 2019 17:52:44 +0100
Subject: [PATCH] evl/thread: hide info bits update into evl_release_thread()

---
 include/evenless/thread.h       |  2 +-
 include/trace/events/evenless.h | 13 ++++++++-----
 kernel/evenless/sched/core.c    |  2 +-
 kernel/evenless/thread.c        | 22 ++++++++++------------
 4 files changed, 20 insertions(+), 19 deletions(-)

diff --git a/include/evenless/thread.h b/include/evenless/thread.h
index 56e511fabce..e73fade656c 100644
--- a/include/evenless/thread.h
+++ b/include/evenless/thread.h
@@ -227,7 +227,7 @@ void evl_hold_thread(struct evl_thread *thread,
 		int mask);
 
 void evl_release_thread(struct evl_thread *thread,
-			int mask);
+			int mask, int info);
 
 bool evl_unblock_thread(struct evl_thread *thread,
 			int reason);
diff --git a/include/trace/events/evenless.h b/include/trace/events/evenless.h
index 95f56c53ad2..9cc9adcd32a 100644
--- a/include/trace/events/evenless.h
+++ b/include/trace/events/evenless.h
@@ -379,23 +379,26 @@ TRACE_EVENT(evl_hold_thread,
 );
 
 TRACE_EVENT(evl_release_thread,
-	TP_PROTO(struct evl_thread *thread, unsigned long mask),
-	TP_ARGS(thread, mask),
+	TP_PROTO(struct evl_thread *thread, int mask, int info),
+	TP_ARGS(thread, mask, info),
 
 	TP_STRUCT__entry(
 		__string(name, thread->name)
 		__field(pid_t, pid)
-		__field(unsigned long, mask)
+		__field(int, mask)
+		__field(int, info)
 	),
 
 	TP_fast_assign(
 		__assign_str(name, thread->name);
 		__entry->pid = evl_get_inband_pid(thread);
 		__entry->mask = mask;
+		__entry->info = info;
 	),
 
-	TP_printk("name=%s pid=%d mask=%#lx",
-		  __get_str(name), __entry->pid, __entry->mask)
+	TP_printk("name=%s pid=%d mask=%#x info=%#x",
+		__get_str(name), __entry->pid,
+		__entry->mask, __entry->info)
 );
 
 TRACE_EVENT(evl_thread_fault,
diff --git a/kernel/evenless/sched/core.c b/kernel/evenless/sched/core.c
index 6618613f7e0..2fe027fab6a 100644
--- a/kernel/evenless/sched/core.c
+++ b/kernel/evenless/sched/core.c
@@ -862,7 +862,7 @@ bool evl_sched_yield(void)
 {
 	struct evl_thread *curr = evl_current();
 
-	evl_release_thread(curr, 0);
+	evl_release_thread(curr, 0, 0);
 
 	return evl_schedule();
 }
diff --git a/kernel/evenless/thread.c b/kernel/evenless/thread.c
index 8ee2820465c..42637d07065 100644
--- a/kernel/evenless/thread.c
+++ b/kernel/evenless/thread.c
@@ -306,7 +306,7 @@ static int map_kthread_self(struct evl_kthread *kthread)
 	dovetail_init_altsched(&curr->altsched);
 	set_oob_threadinfo(curr);
 	dovetail_start_altsched();
-	evl_release_thread(curr, T_DORMANT);
+	evl_release_thread(curr, T_DORMANT, 0);
 
 	trace_evl_thread_map(curr);
 
@@ -435,7 +435,7 @@ void evl_start_thread(struct evl_thread *thread)
 		enlist_new_thread(thread);
 
 	trace_evl_thread_start(thread);
-	evl_release_thread(thread, T_DORMANT);
+	evl_release_thread(thread, T_DORMANT, 0);
 
 	xnlock_put_irqrestore(&nklock, flags);
 
@@ -611,7 +611,7 @@ void evl_hold_thread(struct evl_thread *thread, int mask)
 }
 EXPORT_SYMBOL_GPL(evl_hold_thread);
 
-void evl_release_thread(struct evl_thread *thread, int mask)
+void evl_release_thread(struct evl_thread *thread, int mask, int info)
 {
 	unsigned long oldstate, flags;
 	struct evl_rq *rq;
@@ -621,12 +621,13 @@ void evl_release_thread(struct evl_thread *thread, int mask)
 
 	xnlock_get_irqsave(&nklock, flags);
 
-	trace_evl_release_thread(thread, mask);
+	trace_evl_release_thread(thread, mask, info);
 
 	rq = thread->rq;
 	oldstate = thread->state;
 	if (oldstate & mask) {
 		thread->state &= ~mask;
+		thread->info |= info;
 
 		if (thread->state & EVL_THREAD_BLOCK_BITS)
 			goto out;
@@ -997,15 +998,14 @@ void evl_cancel_thread(struct evl_thread *thread)
 	 * raising the kicked condition bit to make sure it will reach
 	 * evl_test_cancel() on its wakeup path.
 	 *
-	 * NOTE: if T_DORMANT and !T_INBAND, then some non-mapped
+	 * NOTE: if T_DORMANT and !T_INBAND, then some not-yet-mapped
 	 * emerging thread is self-cancelling due to an early error in
 	 * the prep work.
 	 */
 	if (thread->state & T_DORMANT) {
 		if (!(thread->state & T_INBAND))
 			goto check_self_cancel;
-		thread->info |= T_KICKED;
-		evl_release_thread(thread, T_DORMANT);
+		evl_release_thread(thread, T_DORMANT, T_KICKED);
 		goto out;
 	}
 
@@ -1383,10 +1383,8 @@ static bool force_wakeup(struct evl_thread *thread) /* nklock locked, irqs off *
 	 * to detect forcible unblocks from T_SUSP, T_HALT, if they
 	 * should act upon this case specifically.
 	 */
-	if (thread->state & (T_SUSP|T_HALT)) {
-		evl_release_thread(thread, T_SUSP|T_HALT);
-		thread->info |= T_KICKED;
-	}
+	if (thread->state & (T_SUSP|T_HALT))
+		evl_release_thread(thread, T_SUSP|T_HALT, T_KICKED);
 
 	/*
 	 * Tricky cases:
@@ -1815,7 +1813,7 @@ void resume_oob_task(struct task_struct *p) /* hw IRQs off */
 	 */
 	xnlock_get(&nklock);
 	if (affinity_ok(p))
-		evl_release_thread(thread, T_INBAND);
+		evl_release_thread(thread, T_INBAND, 0);
 	xnlock_put(&nklock);
 
 	evl_schedule();
-- 
2.16.4

