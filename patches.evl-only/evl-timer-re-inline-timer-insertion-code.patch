From a7ed5e9d5cb60d4f73233530961a17104be963ae Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Thu, 25 Jul 2019 21:09:39 +0200
Subject: [PATCH] evl/timer: re-inline timer insertion code

Measurements showed no performance gain in full inlining there, only
more code over multiple callers.
---
 include/evl/timer.h | 35 +----------------------------------
 kernel/evl/timer.c  | 33 +++++++++++++++++++++++++++++++++
 2 files changed, 34 insertions(+), 34 deletions(-)

diff --git a/include/evl/timer.h b/include/evl/timer.h
index ae9ce2332ab..ad6ef79684e 100644
--- a/include/evl/timer.h
+++ b/include/evl/timer.h
@@ -369,40 +369,7 @@ void evl_dequeue_timer(struct evl_timer *timer,
 	timer->status |= EVL_TIMER_DEQUEUED;
 }
 
-
-/* same or earlier date. */
-static __always_inline
-bool date_is_earlier(struct evl_tnode *left,
-		struct evl_tnode *right)
-{
-	return left->date < right->date
-		|| (left->date == right->date && left->prio > right->prio);
-}
-
-static __always_inline
-void evl_insert_tnode(struct evl_tqueue *tq, struct evl_tnode *node)
-{
-	struct rb_node **new = &tq->root.rb_node, *parent = NULL;
-
-	if (!tq->head)
-		tq->head = node;
-	else if (date_is_earlier(node, tq->head)) {
-		parent = &tq->head->rb;
-		new = &parent->rb_left;
-		tq->head = node;
-	} else while (*new) {
-			struct evl_tnode *i = container_of(*new, struct evl_tnode, rb);
-
-			parent = *new;
-			if (date_is_earlier(node, i))
-				new = &((*new)->rb_left);
-			else
-				new = &((*new)->rb_right);
-		}
-
-	rb_link_node(&node->rb, parent, new);
-	rb_insert_color(&node->rb, &tq->root);
-}
+void evl_insert_tnode(struct evl_tqueue *tq, struct evl_tnode *node);
 
 /* timer base locked. */
 static __always_inline
diff --git a/kernel/evl/timer.c b/kernel/evl/timer.c
index 7ff0b513f1e..c5ed8531433 100644
--- a/kernel/evl/timer.c
+++ b/kernel/evl/timer.c
@@ -484,3 +484,36 @@ unsigned long evl_get_timer_overruns(struct evl_timer *timer)
 	return overruns;
 }
 EXPORT_SYMBOL_GPL(evl_get_timer_overruns);
+
+static __always_inline
+bool date_is_earlier(struct evl_tnode *left,
+		struct evl_tnode *right)
+{
+	return left->date < right->date
+		|| (left->date == right->date && left->prio > right->prio);
+}
+
+void evl_insert_tnode(struct evl_tqueue *tq, struct evl_tnode *node)
+{
+	struct rb_node **new = &tq->root.rb_node, *parent = NULL;
+
+	if (!tq->head)
+		tq->head = node;
+	else if (date_is_earlier(node, tq->head)) {
+		parent = &tq->head->rb;
+		new = &parent->rb_left;
+		tq->head = node;
+	} else while (*new) {
+			struct evl_tnode *i = container_of(*new, struct evl_tnode, rb);
+
+			parent = *new;
+			if (date_is_earlier(node, i))
+				new = &((*new)->rb_left);
+			else
+				new = &((*new)->rb_right);
+		}
+
+	rb_link_node(&node->rb, parent, new);
+	rb_insert_color(&node->rb, &tq->root);
+}
+EXPORT_SYMBOL_GPL(evl_insert_tnode);
-- 
2.16.4

