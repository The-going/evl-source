From 0c6835a320e41ad05c1c7ba203f1e1db9ed48904 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Sat, 4 May 2019 11:22:12 +0200
Subject: [PATCH] evl/sched: quota: privatize find_quota_group()

---
 include/evl/sched/quota.h |  3 ---
 kernel/evl/sched/quota.c  | 43 +++++++++++++++++++++----------------------
 2 files changed, 21 insertions(+), 25 deletions(-)

diff --git a/include/evl/sched/quota.h b/include/evl/sched/quota.h
index c10b0fadb4a2..94e16f0c6356 100644
--- a/include/evl/sched/quota.h
+++ b/include/evl/sched/quota.h
@@ -65,9 +65,6 @@ void evl_quota_set_limit(struct evl_quota_group *tg,
 			int quota_percent, int quota_peak_percent,
 			int *quota_sum_r);
 
-struct evl_quota_group *
-evl_quota_find_group(struct evl_rq *rq, int tgid);
-
 int evl_quota_sum_all(struct evl_rq *rq);
 
 void evl_set_quota_period(ktime_t period);
diff --git a/kernel/evl/sched/quota.c b/kernel/evl/sched/quota.c
index 9c6fbc69dbba..a2ce8d3645c9 100644
--- a/kernel/evl/sched/quota.c
+++ b/kernel/evl/sched/quota.c
@@ -613,6 +613,24 @@ static void quota_set_limit(struct evl_quota_group *tg,
 	evl_schedule();
 }
 
+static struct evl_quota_group *
+find_quota_group(struct evl_rq *rq, int tgid)
+{
+	struct evl_quota_group *tg;
+
+	requires_ugly_lock();
+
+	if (list_empty(&rq->quota.groups))
+		return NULL;
+
+	list_for_each_entry(tg, &rq->quota.groups, next) {
+		if (tg->tgid == tgid)
+			return tg;
+	}
+
+	return NULL;
+}
+
 static int quota_control(int cpu, union evl_sched_ctlparam *ctlp,
 			union evl_sched_ctlinfo *infp)
 {
@@ -647,7 +665,7 @@ static int quota_control(int cpu, union evl_sched_ctlparam *ctlp,
 	case evl_quota_force_remove:
 		xnlock_get_irqsave(&nklock, flags);
 		rq = evl_cpu_rq(cpu);
-		tg = evl_quota_find_group(rq, pq->u.remove.tgid);
+		tg = find_quota_group(rq, pq->u.remove.tgid);
 		if (tg == NULL)
 			goto bad_tgid;
 		group = container_of(tg, struct evl_sched_group, quota);
@@ -665,7 +683,7 @@ static int quota_control(int cpu, union evl_sched_ctlparam *ctlp,
 	case evl_quota_set:
 		xnlock_get_irqsave(&nklock, flags);
 		rq = evl_cpu_rq(cpu);
-		tg = evl_quota_find_group(rq, pq->u.set.tgid);
+		tg = find_quota_group(rq, pq->u.set.tgid);
 		if (tg == NULL)
 			goto bad_tgid;
 		group = container_of(tg, struct evl_sched_group, quota);
@@ -675,7 +693,7 @@ static int quota_control(int cpu, union evl_sched_ctlparam *ctlp,
 	case evl_quota_get:
 		xnlock_get_irqsave(&nklock, flags);
 		rq = evl_cpu_rq(cpu);
-		tg = evl_quota_find_group(rq, pq->u.get.tgid);
+		tg = find_quota_group(rq, pq->u.get.tgid);
 		if (tg == NULL)
 			goto bad_tgid;
 		quota_sum = quota_sum_all(&rq->quota);
@@ -697,25 +715,6 @@ static int quota_control(int cpu, union evl_sched_ctlparam *ctlp,
 	return -EINVAL;
 }
 
-struct evl_quota_group *
-evl_quota_find_group(struct evl_rq *rq, int tgid)
-{
-	struct evl_quota_group *tg;
-
-	requires_ugly_lock();
-
-	if (list_empty(&rq->quota.groups))
-		return NULL;
-
-	list_for_each_entry(tg, &rq->quota.groups, next) {
-		if (tg->tgid == tgid)
-			return tg;
-	}
-
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(evl_quota_find_group);
-
 void evl_set_quota_period(ktime_t period)
 {
 	quota_period = period;
-- 
2.16.4

