From a21c26b8d4b3b2340b51e911f576e71c0645b987 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Sun, 20 Oct 2019 12:29:35 +0200
Subject: [PATCH] evl/thread: detect preposterous absolute timeout in sleep_on

Botched evl_sleep_on() calls with absolute timeout values set into the
past can easily lead to timer event storm, then stack overflows as IRQ
frames pile up.

Detect such cases early prior to starting the resource timer, so that
the offending caller receives a timeout condition immediately,
skipping the timer chip programming.
---
 kernel/evl/thread.c | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/kernel/evl/thread.c b/kernel/evl/thread.c
index 8eb696ac40c4..acde088e96dc 100644
--- a/kernel/evl/thread.c
+++ b/kernel/evl/thread.c
@@ -478,8 +478,7 @@ void evl_sleep_on(ktime_t timeout, enum evl_tmode timeout_mode,
 			}
 			curr->info &= ~(T_RMID|T_TIMEO);
 			curr->info |= T_BREAK;
-			xnlock_put_irqrestore(&nklock, flags);
-			return;
+			goto out;
 		}
 		curr->info &= ~EVL_THREAD_INFO_MASK;
 	}
@@ -495,6 +494,10 @@ void evl_sleep_on(ktime_t timeout, enum evl_tmode timeout_mode,
 				evl_thread_rq(curr));
 		if (timeout_mode == EVL_REL)
 			timeout = evl_abs_timeout(&curr->rtimer, timeout);
+		else if (timeout <= evl_read_clock(clock)) {
+			curr->info |= T_TIMEO;
+			goto out;
+		}
 		evl_start_timer(&curr->rtimer, timeout, EVL_INFINITE);
 		curr->state |= T_DELAY;
 	} else if (!wchan) {
@@ -514,7 +517,7 @@ void evl_sleep_on(ktime_t timeout, enum evl_tmode timeout_mode,
 	}
 
 	evl_set_resched(rq);
-
+out:
 	xnlock_put_irqrestore(&nklock, flags);
 }
 EXPORT_SYMBOL_GPL(evl_sleep_on);
-- 
2.16.4

