From e3e6cba8bfb551d4d2ac337c683d5d549fa8d34c Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Sat, 13 Jul 2019 20:16:11 +0200
Subject: [PATCH] evl/clock: assume hard irqs off on clock tick

Callers of evl_announce_tick() and evl_core_tick() are expected to run
over an interrupt context, so we may assume hard irqs off on entry.
---
 kernel/evl/clock.c | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/kernel/evl/clock.c b/kernel/evl/clock.c
index bd1fab485d4..c8428b09693 100644
--- a/kernel/evl/clock.c
+++ b/kernel/evl/clock.c
@@ -280,11 +280,13 @@ static void do_clock_tick(struct evl_clock *clock, struct evl_timerbase *tmb)
 	struct evl_timer *timer;
 	struct evl_tqueue *tq;
 	struct evl_tnode *tn;
-	unsigned long flags;
 	ktime_t now;
 
+	if (EVL_WARN_ON_ONCE(CORE, !hard_irqs_disabled()))
+		hard_local_irq_disable();
+
 	tq = &tmb->q;
-	raw_spin_lock_irqsave(&tmb->lock, flags);
+	raw_spin_lock(&tmb->lock);
 
 	/*
 	 * Optimisation: any local timer reprogramming triggered by
@@ -312,9 +314,9 @@ static void do_clock_tick(struct evl_clock *clock, struct evl_timerbase *tmb)
 			} while (evl_tdate(timer) < now);
 		}
 
-		raw_spin_unlock_irqrestore(&tmb->lock, flags);
+		raw_spin_unlock(&tmb->lock);
 		timer->handler(timer);
-		raw_spin_lock_irqsave(&tmb->lock, flags);
+		raw_spin_lock(&tmb->lock);
 
 		if (timer_needs_enqueuing(timer) &&
 			evl_timer_on_rq(timer, rq))
@@ -325,7 +327,7 @@ static void do_clock_tick(struct evl_clock *clock, struct evl_timerbase *tmb)
 
 	evl_program_local_tick(clock);
 
-	raw_spin_unlock_irqrestore(&tmb->lock, flags);
+	raw_spin_unlock(&tmb->lock);
 }
 
 void evl_core_tick(struct clock_event_device *dummy) /* hard irqs off */
-- 
2.16.4

