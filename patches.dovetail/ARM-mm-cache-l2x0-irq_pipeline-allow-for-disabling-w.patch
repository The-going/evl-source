From 2ddb1dbb56c1db0a27e502937c8b4a58a626b27a Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Sun, 11 Dec 2016 18:07:58 +0100
Subject: [PATCH] ARM/mm: cache-l2x0: irq_pipeline: allow for disabling
 write-allocate

HACK ALERT. Introduce the 'l2x0_write_allocate' kernel switch for
controlling the write-allocate policy. Such policy is known to induce
very high latencies: it typically doubles the worst-case figures on
imx6q with cache revisions of the PL310 controller earlier than r3p2.

By default, the default policy is usually determined by the AWCACHE
attribute settings unless the platform code forced it in the auxiliary
control register. In the common case, write allocation is selected.

The patch conditionally changes this setting as follows:

- if the cache controller is a PL210, or a PL310 advertising revision
  r3p2 or later, keep WA enabled unless forced off by
  l2x0_write_allocate=0.

- if the cache controller is a PL220, or a PL310 advertising a
  revision earlier than r3p2, and WA was NOT forced off, issue an
  alert about possibly higher latency figures.

We do know that disabling WA on SMP may be architecturally wrong on
ARM, but this happens to work on i.MX6 hardware with early L2 cache
controllers.
---
 arch/arm/mm/cache-l2x0.c | 28 ++++++++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/arch/arm/mm/cache-l2x0.c b/arch/arm/mm/cache-l2x0.c
index 808efbb89b8..cf5d6bd6ca4 100644
--- a/arch/arm/mm/cache-l2x0.c
+++ b/arch/arm/mm/cache-l2x0.c
@@ -60,6 +60,16 @@ struct l2x0_regs l2x0_saved_regs;
 static bool l2x0_bresp_disable;
 static bool l2x0_flz_disable;
 
+#ifdef CONFIG_IRQ_PIPELINE
+static int l2x0_wa = -1;
+static int __init l2x0_setup_wa(char *str)
+{
+	l2x0_wa = !!simple_strtol(str, NULL, 0);
+	return 0;
+}
+early_param("l2x0_write_allocate", l2x0_setup_wa);
+#endif
+
 /*
  * Common code for all cache controllers.
  */
@@ -812,6 +822,24 @@ static int __init __l2c_init(const struct l2c_init_data *data,
 	if (aux_val & aux_mask)
 		pr_alert("L2C: platform provided aux values permit register corruption.\n");
 
+#ifdef CONFIG_IRQ_PIPELINE
+	if (!l2x0_wa) {
+		/*
+		 * Disable WA by setting bit 23 in the auxiliary
+		 * control register.
+		 */
+		aux_mask &= ~L220_AUX_CTRL_FWA_MASK;
+		aux_val &= ~L220_AUX_CTRL_FWA_MASK;
+		aux_val |= 1 << L220_AUX_CTRL_FWA_SHIFT;
+		pr_warn("%s: irq_pipeline: write-allocate disabled via command line\n",
+			data->type);
+	} else if ((cache_id & L2X0_CACHE_ID_PART_MASK) == L2X0_CACHE_ID_PART_L220 ||
+		   ((cache_id & L2X0_CACHE_ID_PART_MASK) == L2X0_CACHE_ID_PART_L310 &&
+		    (cache_id & L2X0_CACHE_ID_RTL_MASK) < L310_CACHE_ID_RTL_R3P2))
+		pr_alert("%s: irq_pipeline: write-allocate enabled, may induce high latency\n",
+			 data->type);
+#endif
+
 	old_aux = aux = readl_relaxed(l2x0_base + L2X0_AUX_CTRL);
 	aux &= aux_mask;
 	aux |= aux_val;
-- 
2.16.4

