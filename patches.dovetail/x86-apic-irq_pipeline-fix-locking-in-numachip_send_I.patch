From feaf7d36c0a30c74b13877d958fde5ca96179452 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Mon, 27 May 2019 11:29:30 +0200
Subject: [PATCH] x86/apic: irq_pipeline: fix locking in
 numachip_send_IPI_one()

There is no reason to convert the preempt_disable/enable() sequence to
its hard form in this case, only because the caller might run on the
oob stage. preempt_*() calls are oob-compatible by construction since
STAGE_MASK is part of the preempt count, and migration cannot happen
from the oob stage.

We want __default_send_IPI_dest_field() to be called with hard IRQs
off though, since the oob stage must not re-enter this routine while
some inband caller is still there.
---
 arch/x86/kernel/apic/apic_numachip.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/arch/x86/kernel/apic/apic_numachip.c b/arch/x86/kernel/apic/apic_numachip.c
index 0247281d9265..28293cd80eeb 100644
--- a/arch/x86/kernel/apic/apic_numachip.c
+++ b/arch/x86/kernel/apic/apic_numachip.c
@@ -96,7 +96,7 @@ static void numachip_send_IPI_one(int cpu, int vector)
 	int local_apicid, apicid = per_cpu(x86_cpu_to_apicid, cpu);
 	unsigned int dmode;
 
-	hard_preempt_disable();
+	preempt_disable();
 	local_apicid = __this_cpu_read(x86_cpu_to_apicid);
 
 	/* Send via local APIC where non-local part matches */
@@ -107,10 +107,10 @@ static void numachip_send_IPI_one(int cpu, int vector)
 		__default_send_IPI_dest_field(apicid, vector,
 			APIC_DEST_PHYSICAL);
 		hard_local_irq_restore(flags);
-		hard_preempt_enable();
+		preempt_enable();
 		return;
 	}
-	hard_preempt_enable();
+	preempt_enable();
 
 	dmode = (vector == NMI_VECTOR) ? APIC_DM_NMI : APIC_DM_FIXED;
 	numachip_apic_icr_write(apicid, dmode | vector);
-- 
2.16.4

