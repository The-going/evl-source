From 9fae6c8dd7953e341a45090f7387bf6a619c66f2 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Sun, 28 Apr 2019 19:36:20 +0200
Subject: [PATCH] locking: irq_pipeline: make debug optional for hard spinlocks

---
 include/asm-generic/irq_pipeline.h |  2 +-
 include/linux/lockdep.h            | 31 ++++++++++++++++---------------
 include/linux/spinlock_pipeline.h  | 22 ++++++++++++++--------
 include/linux/spinlock_types.h     | 32 ++++++++++++++++++++++++++++++--
 kernel/irq/pipeline.c              | 23 +++++++++++++++++------
 kernel/locking/lockdep.c           |  3 ---
 lib/Kconfig.debug                  | 20 ++++++++++++++++++--
 7 files changed, 96 insertions(+), 37 deletions(-)

diff --git a/include/asm-generic/irq_pipeline.h b/include/asm-generic/irq_pipeline.h
index d818ebfd9f8e..4263f7044f95 100644
--- a/include/asm-generic/irq_pipeline.h
+++ b/include/asm-generic/irq_pipeline.h
@@ -114,7 +114,7 @@ static inline bool irq_pipeline_debug(void)
 
 static inline bool irq_pipeline_debug_locking(void)
 {
-	return irqs_pipelined() && IS_ENABLED(CONFIG_LOCKDEP);
+	return IS_ENABLED(CONFIG_DEBUG_HARD_LOCKS);
 }
 
 #endif /* __ASM_GENERIC_IRQ_PIPELINE_H */
diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h
index 7da91e32b3d6..8f95ee91f576 100644
--- a/include/linux/lockdep.h
+++ b/include/linux/lockdep.h
@@ -312,14 +312,14 @@ extern void lockdep_init_map(struct lockdep_map *lock, const char *name,
  * or they are too narrow (they suffer from a false class-split):
  */
 #define lockdep_set_class(lock, key) \
-	lockdep_init_map(LOCKDEP_ALTERNATIVES(lock), #key, key, 0)
+	lockdep_init_map(LOCKDEP_ALT_DEPMAP(lock), #key, key, 0)
 #define lockdep_set_class_and_name(lock, key, name) \
-	lockdep_init_map(LOCKDEP_ALTERNATIVES(lock), name, key, 0)
+	lockdep_init_map(LOCKDEP_ALT_DEPMAP(lock), name, key, 0)
 #define lockdep_set_class_and_subclass(lock, key, sub) \
-	lockdep_init_map(LOCKDEP_ALTERNATIVES(lock), #key, key, sub)
+	lockdep_init_map(LOCKDEP_ALT_DEPMAP(lock), #key, key, sub)
 #define lockdep_set_subclass(lock, sub)	\
-	lockdep_init_map(LOCKDEP_ALTERNATIVES(lock), #lock,	\
-			 LOCKDEP_ALTERNATIVES(lock)->key, sub)
+	lockdep_init_map(LOCKDEP_ALT_DEPMAP(lock), #lock,	\
+			 LOCKDEP_ALT_DEPMAP(lock)->key, sub)
 
 #define lockdep_set_novalidate_class(lock) \
 	lockdep_set_class_and_name(lock, &__lockdep_no_validate__, #lock)
@@ -327,7 +327,7 @@ extern void lockdep_init_map(struct lockdep_map *lock, const char *name,
  * Compare locking classes
  */
 #define lockdep_match_class(lock, key) \
-	lockdep_match_key(LOCKDEP_ALTERNATIVES(lock), key)
+	lockdep_match_key(LOCKDEP_ALT_DEPMAP(lock), key)
 
 static inline int lockdep_match_key(struct lockdep_map *lock,
 				    struct lock_class_key *key)
@@ -366,8 +366,8 @@ static inline int lock_is_held(const struct lockdep_map *lock)
 	return lock_is_held_type(lock, -1);
 }
 
-#define lockdep_is_held(lock)		lock_is_held(LOCKDEP_ALTERNATIVES(lock))
-#define lockdep_is_held_type(lock, r)	lock_is_held_type(LOCKDEP_ALTERNATIVES(lock), (r))
+#define lockdep_is_held(lock)		lock_is_held(LOCKDEP_ALT_DEPMAP(lock))
+#define lockdep_is_held_type(lock, r)	lock_is_held_type(LOCKDEP_ALT_DEPMAP(lock), (r))
 
 extern void lock_set_class(struct lockdep_map *lock, const char *name,
 			   struct lock_class_key *key, unsigned int subclass,
@@ -392,26 +392,27 @@ extern void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie);
 #define lockdep_depth(tsk)	(debug_locks ? (tsk)->lockdep_depth : 0)
 
 #define lockdep_assert_held(l)	do {				\
-		WARN_ON(debug_locks && !lockdep_is_held(l));	\
+		WARN_ON(debug_locks && !LOCKDEP_HARD_DEBUG_RET(l, 1, lockdep_is_held(l))); \
 	} while (0)
 
 #define lockdep_assert_held_write(l)	do {			\
-		WARN_ON(debug_locks && !lockdep_is_held_type(l, 0));	\
+		WARN_ON(debug_locks && !LOCKDEP_HARD_DEBUG_RET(l, 1, lockdep_is_held_type(l, 0))); \
 	} while (0)
 
 #define lockdep_assert_held_read(l)	do {				\
-		WARN_ON(debug_locks && !lockdep_is_held_type(l, 1));	\
+		WARN_ON(debug_locks && !LOCKDEP_HARD_DEBUG_RET(l, 1, lockdep_is_held_type(l, 1))); \
 	} while (0)
 
 #define lockdep_assert_held_once(l)	do {				\
-		WARN_ON_ONCE(debug_locks && !lockdep_is_held(l));	\
+		WARN_ON_ONCE(debug_locks && !LOCKDEP_HARD_DEBUG_RET(l, 1, lockdep_is_held(l))); \
 	} while (0)
 
 #define lockdep_recursing(tsk)	((tsk)->lockdep_recursion)
 
-#define lockdep_pin_lock(l)	lock_pin_lock(&(l)->dep_map)
-#define lockdep_repin_lock(l,c)	lock_repin_lock(&(l)->dep_map, (c))
-#define lockdep_unpin_lock(l,c)	lock_unpin_lock(&(l)->dep_map, (c))
+#define lockdep_pin_lock(l)	LOCKDEP_HARD_DEBUG_RET(l, ({ struct pin_cookie cookie; cookie;} ), \
+							lock_pin_lock(LOCKDEP_ALT_DEPMAP(l)))
+#define lockdep_repin_lock(l,c)	LOCKDEP_HARD_DEBUG(l,, lock_repin_lock(LOCKDEP_ALT_DEPMAP(l), (c)))
+#define lockdep_unpin_lock(l,c)	LOCKDEP_HARD_DEBUG(l,, lock_unpin_lock(LOCKDEP_ALT_DEPMAP(l), (c)))
 
 #else /* !CONFIG_LOCKDEP */
 
diff --git a/include/linux/spinlock_pipeline.h b/include/linux/spinlock_pipeline.h
index 8fb975c22389..57e93847e1c0 100644
--- a/include/linux/spinlock_pipeline.h
+++ b/include/linux/spinlock_pipeline.h
@@ -24,7 +24,21 @@
 
 #define mutable_spin_lock_init(__rlock)	hard_spin_lock_init(__rlock)
 
+/*
+ * CAUTION: We don't want the hand-coded irq-enable of
+ * do_raw_spin_lock_flags(), hard locked sections assume that
+ * interrupts are not re-enabled during lock-acquire.
+ */
 #define hard_lock_acquire(__rlock, __try, __ip)				\
+	do {								\
+		if (irq_pipeline_debug_locking()) {			\
+			spin_acquire(&(__rlock)->dep_map, 0, __try, __ip); \
+			LOCK_CONTENDED(__rlock, do_raw_spin_trylock, do_raw_spin_lock); \
+		} else							\
+			do_raw_spin_lock(__rlock);			\
+	} while (0)
+
+#define hard_trylock_acquire(__rlock, __try, __ip)			\
 	do {								\
 		if (irq_pipeline_debug_locking())			\
 			spin_acquire(&(__rlock)->dep_map, 0, __try, __ip); \
@@ -57,7 +71,6 @@ static inline
 void hard_spin_lock(struct raw_spinlock *rlock)
 {
 	hard_lock_acquire(rlock, 0, _THIS_IP_);
-	LOCK_CONTENDED(rlock, do_raw_spin_trylock, do_raw_spin_lock);
 }
 
 static inline
@@ -72,7 +85,6 @@ void hard_spin_lock_irq(struct raw_spinlock *rlock)
 {
 	hard_local_irq_disable();
 	hard_lock_acquire(rlock, 0, _THIS_IP_);
-	LOCK_CONTENDED(rlock, do_raw_spin_trylock, do_raw_spin_lock);
 }
 
 static inline
@@ -98,12 +110,6 @@ unsigned long __hard_spin_lock_irqsave(struct raw_spinlock *rlock)
 	unsigned long flags = hard_local_irq_save();
 
 	hard_lock_acquire(rlock, 0, _THIS_IP_);
-	/*
-	 * We don't want the hand-coded irq-enable of
-	 * do_raw_spin_lock_flags(), hard locked sections assume that
-	 * interrupts are not re-enabled during lock-acquire.
-	 */
-	LOCK_CONTENDED(rlock, do_raw_spin_trylock, do_raw_spin_lock);
 
 	return flags;
 }
diff --git a/include/linux/spinlock_types.h b/include/linux/spinlock_types.h
index 52b0f426bddb..50a9860b4cca 100644
--- a/include/linux/spinlock_types.h
+++ b/include/linux/spinlock_types.h
@@ -118,7 +118,7 @@ void __bad_spinlock_type(void);
 		__ret;							\
 	})
 
-#define LOCKDEP_ALTERNATIVES(__lock)					\
+#define LOCKDEP_ALT_DEPMAP(__lock)					\
 	({								\
 		struct lockdep_map *__ret;				\
 		if (__builtin_types_compatible_p(typeof(&(__lock)->dep_map), \
@@ -129,6 +129,30 @@ void __bad_spinlock_type(void);
 		__ret;							\
 	})
 
+#define LOCKDEP_HARD_DEBUG(__lock, __nodebug, __debug)	\
+	do {						\
+		if (__builtin_types_compatible_p(typeof(__lock),	\
+						raw_spinlock_t *) ||	\
+			irq_pipeline_debug_locking()) {			\
+			__debug;			\
+		} else {				\
+			__nodebug;			\
+		}					\
+	} while (0)
+
+#define LOCKDEP_HARD_DEBUG_RET(__lock, __nodebug, __debug)	\
+	({						\
+		typeof(__nodebug) __ret;		\
+		if (__builtin_types_compatible_p(typeof(__lock),	\
+						raw_spinlock_t *) ||	\
+			irq_pipeline_debug_locking()) {			\
+			__ret = (__debug);		\
+		} else {				\
+			__ret = (__nodebug);		\
+		}					\
+		__ret;					\
+	})
+
 #define __HARD_SPIN_LOCK_UNLOCKED(__rlock)	\
 	__RAW_SPIN_LOCK_UNLOCKED(__rlock)
 
@@ -174,7 +198,11 @@ typedef raw_spinlock_t mutable_spinlock_t;
 #define LOCK_ALTERNATIVES_RET(__lock, __base_op, __raw_form, __args...) \
 	__raw_form
 
-#define LOCKDEP_ALTERNATIVES(__lock)	(&(__lock)->dep_map)
+#define LOCKDEP_ALT_DEPMAP(__lock)	(&(__lock)->dep_map)
+
+#define LOCKDEP_HARD_DEBUG(__lock, __nondebug, __debug)		do { __debug; } while (0)
+
+#define LOCKDEP_HARD_DEBUG_RET(__lock, __nondebug, __debug)	({ __debug; })
 
 #define DEFINE_HARD_SPINLOCK(x)		DEFINE_RAW_SPINLOCK(x)
 
diff --git a/kernel/irq/pipeline.c b/kernel/irq/pipeline.c
index 962550ca59af..b63f16dc6b32 100644
--- a/kernel/irq/pipeline.c
+++ b/kernel/irq/pipeline.c
@@ -492,6 +492,11 @@ trace_on_debug unsigned long test_and_disable_stage(int *irqsoff)
 	if (running_inband()) {
 		stalled = test_and_set_stage_bit(STAGE_STALL_BIT,
 						 this_inband_staged());
+		if (!irq_pipeline_debug_locking()) {
+			trace_hardirqs_off();
+			if (!*irqsoff)
+				hard_local_irq_enable();
+		}
 		flags = irqs_merge_flags(flags, stalled);
 		if (stalled)
 			*irqsoff = 1;
@@ -520,20 +525,26 @@ trace_on_debug void restore_stage(unsigned long combo)
 	unsigned long flags = combo;
 	int stalled;
 
-	WARN_ON_ONCE(irq_pipeline_debug() && !hard_irqs_disabled());
+	WARN_ON_ONCE(irq_pipeline_debug_locking() && !hard_irqs_disabled());
 
 	if (running_inband()) {
 		flags = irqs_split_flags(combo, &stalled);
-		if (!stalled)
+		if (!stalled) {
+			if (!irq_pipeline_debug_locking()) {
+				hard_local_irq_disable();
+				trace_hardirqs_on();
+			}
 			clear_stage_bit(STAGE_STALL_BIT,
 					this_inband_staged());
+		}
 	}
 
 	/*
-	 * The interrupt bit is the only hardware flag present in the
-	 * combo state, all other status bits have been cleared by
-	 * irqs_merge_flags(), so don't ever try to reload the
-	 * hardware status register with such value directly!
+	 * The hardware interrupt bit is the only flag which may be
+	 * present in the combo state at this point, all other status
+	 * bits have been cleared by irqs_merge_flags(), so don't ever
+	 * try to reload the hardware status register with such value
+	 * directly!
 	 */
 	if (!hard_irqs_disabled_flags(flags))
 		hard_local_irq_enable();
diff --git a/kernel/locking/lockdep.c b/kernel/locking/lockdep.c
index 1f3126c548cd..4a2452658078 100644
--- a/kernel/locking/lockdep.c
+++ b/kernel/locking/lockdep.c
@@ -724,8 +724,6 @@ static inline void lockdep_stage_restore(unsigned long flags)
 	restore_stage(flags);
 }
 
-#define lockdep_stage_save_flags(__flags)	stage_save_flags(__flags)
-
 #else
 
 #define lockdep_stage_test_and_disable(__irqsoff)		\
@@ -744,7 +742,6 @@ static inline void lockdep_stage_restore(unsigned long flags)
 	})
 
 #define lockdep_stage_restore(__flags)		raw_local_irq_restore(__flags)
-#define lockdep_stage_save_flags(__flags)	raw_local_save_flags(__flags)
 
 #endif /* !CONFIG_IRQ_PIPELINE */
 
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index dafbfb53bc46..b395882c0c4f 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -1171,6 +1171,7 @@ config LOCK_STAT
 	select DEBUG_MUTEXES
 	select DEBUG_RT_MUTEXES if RT_MUTEXES
 	select DEBUG_LOCK_ALLOC
+	select DEBUG_HARD_LOCKS
 	default n
 	help
 	 This feature enables tracking lock contention points
@@ -1248,8 +1249,23 @@ config DEBUG_LOCK_ALLOC
 	 spin_lock_init()/mutex_init()/etc., or whether there is any lock
 	 held during task exit.
 
-if IRQ_PIPELINE && PROVE_LOCKING
-comment "WARNING! PROVE_LOCKING induces **massive** latency"
+config DEBUG_HARD_LOCKS
+	bool "Debug hard spinlocks"
+	depends on DEBUG_IRQ_PIPELINE && LOCKDEP
+	---help---
+	  Turn on this option for enabling LOCKDEP for hard spinlock
+	  types used in interrupt pipelining.
+
+	  Keep in mind that enabling such feature will ruin the
+	  latency figures for any out-of-band code, this is merely
+	  useful for proving the correctness of the locking scheme of
+	  such code without any consideration for real-time
+	  guarantees. You have been warned.
+
+	  If unsure, say N.
+
+if DEBUG_HARD_LOCKS
+comment "WARNING! DEBUG_HARD_LOCKS induces **massive** latency"
 comment "overhead for the code running on the out-of-band"
 comment "interrupt stage."
 endif
-- 
2.16.4

