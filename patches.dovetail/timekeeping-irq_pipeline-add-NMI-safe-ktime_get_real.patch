From 887daa44ae318eaf2e856d827c3a485e246b8e86 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Sat, 6 May 2017 18:28:49 +0200
Subject: [PATCH] timekeeping: irq_pipeline: add NMI-safe ktime_get_real_fast()
 helper

We need a way for an activity running in the head stage context to
access the wallclock time, which conceptually means to have a NMI-safe
implementation.

Provide a basic implementation substracting a safe copy of the
wallclock-to-monotonic offset from the monotonic time returned by
ktime_get_mono_fast_ns() which is NMI-safe too.

Signed-off-by: Philippe Gerum <rpm@xenomai.org>
---
 include/linux/timekeeping.h |  1 +
 include/vdso/helpers.h      |  2 ++
 kernel/time/timekeeping.c   | 15 +++++++++++++++
 3 files changed, 18 insertions(+)

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index b27e2ffa96c1..31278a7c4833 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -69,6 +69,7 @@ extern ktime_t ktime_get_with_offset(enum tk_offsets offs);
 extern ktime_t ktime_get_coarse_with_offset(enum tk_offsets offs);
 extern ktime_t ktime_mono_to_any(ktime_t tmono, enum tk_offsets offs);
 extern ktime_t ktime_get_raw(void);
+extern ktime_t ktime_get_real_fast(void);
 extern u32 ktime_get_resolution_ns(void);
 
 /**
diff --git a/include/vdso/helpers.h b/include/vdso/helpers.h
index 01641dbb68ef..3f378e332f41 100644
--- a/include/vdso/helpers.h
+++ b/include/vdso/helpers.h
@@ -34,6 +34,7 @@ static __always_inline void vdso_write_begin(struct vdso_data *vd)
 	 * updates to vd[x].seq and it is possible that the value seen by the
 	 * reader it is inconsistent.
 	 */
+	hard_cond_local_irq_disable();
 	WRITE_ONCE(vd[CS_HRES_COARSE].seq, vd[CS_HRES_COARSE].seq + 1);
 	WRITE_ONCE(vd[CS_RAW].seq, vd[CS_RAW].seq + 1);
 	smp_wmb();
@@ -49,6 +50,7 @@ static __always_inline void vdso_write_end(struct vdso_data *vd)
 	 */
 	WRITE_ONCE(vd[CS_HRES_COARSE].seq, vd[CS_HRES_COARSE].seq + 1);
 	WRITE_ONCE(vd[CS_RAW].seq, vd[CS_RAW].seq + 1);
+	hard_cond_local_irq_enable();
 }
 
 #endif /* !__ASSEMBLY__ */
diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c
index ca69290bee2a..c13489d2e890 100644
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@ -89,6 +89,8 @@ static struct tk_fast tk_fast_raw  ____cacheline_aligned = {
 	.base[1] = { .clock = &dummy_clock, },
 };
 
+static struct timespec64 fast_wall_to_monotonic ____cacheline_aligned;
+
 /* flag for if timekeeping is suspended */
 int __read_mostly timekeeping_suspended;
 
@@ -510,6 +512,16 @@ u64 notrace ktime_get_boot_fast_ns(void)
 }
 EXPORT_SYMBOL_GPL(ktime_get_boot_fast_ns);
 
+ktime_t ktime_get_real_fast(void)
+{
+	ktime_t mono, wtm;
+
+	mono = ns_to_ktime(ktime_get_mono_fast_ns());
+	wtm = timespec64_to_ktime(fast_wall_to_monotonic);
+
+	return ktime_sub(mono, wtm);
+}
+EXPORT_SYMBOL_GPL(ktime_get_real_fast);
 
 /*
  * See comment for __ktime_get_fast_ns() vs. timestamp ordering
@@ -569,6 +581,8 @@ static void halt_fast_timekeeper(const struct timekeeper *tk)
 	memcpy(&tkr_dummy, tkr, sizeof(tkr_dummy));
 	tkr_dummy.clock = &dummy_clock;
 	update_fast_timekeeper(&tkr_dummy, &tk_fast_raw);
+
+	fast_wall_to_monotonic = tk->wall_to_monotonic;
 }
 
 static RAW_NOTIFIER_HEAD(pvclock_gtod_chain);
@@ -674,6 +688,7 @@ static void timekeeping_update(struct timekeeper *tk, unsigned int action)
 	tk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;
 	update_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);
 	update_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);
+	fast_wall_to_monotonic = tk->wall_to_monotonic;
 
 	if (action & TK_CLOCK_WAS_SET)
 		tk->clock_was_set_seq++;
-- 
2.16.4

