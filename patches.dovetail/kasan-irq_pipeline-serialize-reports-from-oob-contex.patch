From 577d5f3585a2bf0218e836e2f9f3bb2d915b7fa4 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Thu, 20 Dec 2018 15:28:26 +0100
Subject: [PATCH] kasan: irq_pipeline: serialize reports from oob contexts

KASAN may detect issues in code running out-of-band, so we have to
serialize the report handler accordingly by turning the regular
spinlock into a hard lock.

This will trigger massive a latency spot when a report is emitted, but
since kernel sanity is at stake when this happens, such spike is not
the most urgent issue.

This also means that the KASAN report lock becomes a raw lock -
therefore cannot sleep with full preemption enabled.
---
 mm/kasan/report.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/mm/kasan/report.c b/mm/kasan/report.c
index 0e5f965f1882..b52609499fc8 100644
--- a/mm/kasan/report.c
+++ b/mm/kasan/report.c
@@ -75,7 +75,7 @@ static void print_error_description(struct kasan_access_info *info)
 		info->access_addr, current->comm, task_pid_nr(current));
 }
 
-static DEFINE_SPINLOCK(report_lock);
+static DEFINE_HARD_SPINLOCK(report_lock);
 
 static void start_report(unsigned long *flags)
 {
@@ -83,7 +83,7 @@ static void start_report(unsigned long *flags)
 	 * Make sure we don't end up in loop.
 	 */
 	kasan_disable_current();
-	spin_lock_irqsave(&report_lock, *flags);
+	raw_spin_lock_irqsave(&report_lock, *flags);
 	pr_err("==================================================================\n");
 }
 
@@ -91,7 +91,7 @@ static void end_report(unsigned long *flags)
 {
 	pr_err("==================================================================\n");
 	add_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);
-	spin_unlock_irqrestore(&report_lock, *flags);
+	raw_spin_unlock_irqrestore(&report_lock, *flags);
 	if (panic_on_warn)
 		panic("panic_on_warn set ...\n");
 	kasan_enable_current();
-- 
2.16.4

