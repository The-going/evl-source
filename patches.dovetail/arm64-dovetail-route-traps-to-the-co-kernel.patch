From 8878aab3129419197adbc9c437ce7d6f23b5413e Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Fri, 14 Sep 2018 11:17:29 +0200
Subject: [PATCH] arm64: dovetail: route traps to the co-kernel

---
 arch/arm64/include/asm/dovetail.h | 10 ++++++++++
 arch/arm64/kernel/fpsimd.c        |  5 +++++
 arch/arm64/kernel/ptrace.c        |  2 ++
 arch/arm64/kernel/traps.c         |  4 ++++
 arch/arm64/mm/fault.c             | 34 ++++++++++++++++++++++++++--------
 5 files changed, 47 insertions(+), 8 deletions(-)

diff --git a/arch/arm64/include/asm/dovetail.h b/arch/arm64/include/asm/dovetail.h
index 8c0af9bbf972..c2c0ae6c1e05 100644
--- a/arch/arm64/include/asm/dovetail.h
+++ b/arch/arm64/include/asm/dovetail.h
@@ -6,4 +6,14 @@
 #ifndef _ASM_ARM64_DOVETAIL_H
 #define _ASM_ARM64_DOVETAIL_H
 
+/* ARM64 traps */
+#define ARM64_TRAP_ACCESS	0	/* Data or instruction access exception */
+#define ARM64_TRAP_ABRT		1	/* Memory/alignment abort */
+#define ARM64_TRAP_SEA		2	/* Synchronous external abort */
+#define ARM64_TRAP_DEBUG	3	/* Debug trap */
+#define ARM64_TRAP_UNDI		4	/* Undefined instruction */
+#define ARM64_TRAP_UNDSE	5	/* Undefined synchronous exception */
+#define ARM64_TRAP_FPE		6	/* FPSIMD exception */
+#define ARM64_TRAP_SVE		7	/* SVE access trap */
+
 #endif /* _ASM_ARM64_DOVETAIL_H */
diff --git a/arch/arm64/kernel/fpsimd.c b/arch/arm64/kernel/fpsimd.c
index a38bf74bcca8..1d62ee4e06ab 100644
--- a/arch/arm64/kernel/fpsimd.c
+++ b/arch/arm64/kernel/fpsimd.c
@@ -39,6 +39,7 @@
 #include <linux/slab.h>
 #include <linux/stddef.h>
 #include <linux/sysctl.h>
+#include <linux/dovetail.h>
 
 #include <asm/esr.h>
 #include <asm/fpsimd.h>
@@ -859,6 +860,8 @@ void fpsimd_release_task(struct task_struct *dead_task)
  */
 asmlinkage void do_sve_acc(unsigned int esr, struct pt_regs *regs)
 {
+	oob_trap_notify(ARM64_TRAP_SVE, regs);
+
 	/* Even if we chose not to use SVE, the hardware could still trap: */
 	if (unlikely(!system_supports_sve()) || WARN_ON(is_compat_task())) {
 		force_signal_inject(SIGILL, ILL_ILLOPC, regs->pc);
@@ -910,6 +913,8 @@ asmlinkage void do_fpsimd_exc(unsigned int esr, struct pt_regs *regs)
 			si_code = FPE_FLTRES;
 	}
 
+	oob_trap_notify(ARM64_TRAP_FPE, regs);
+
 	send_sig_fault(SIGFPE, si_code,
 		       (void __user *)instruction_pointer(regs),
 		       current);
diff --git a/arch/arm64/kernel/ptrace.c b/arch/arm64/kernel/ptrace.c
index b82e0a9b3da3..8873ded43566 100644
--- a/arch/arm64/kernel/ptrace.c
+++ b/arch/arm64/kernel/ptrace.c
@@ -185,6 +185,8 @@ static void ptrace_hbptriggered(struct perf_event *bp,
 	struct arch_hw_breakpoint *bkpt = counter_arch_bp(bp);
 	const char *desc = "Hardware breakpoint trap (ptrace)";
 
+	oob_trap_notify(ARM64_TRAP_DEBUG, regs);
+
 #ifdef CONFIG_COMPAT
 	if (is_compat_task()) {
 		int si_errno = 0;
diff --git a/arch/arm64/kernel/traps.c b/arch/arm64/kernel/traps.c
index dc24be8cf87d..294a973da7a8 100644
--- a/arch/arm64/kernel/traps.c
+++ b/arch/arm64/kernel/traps.c
@@ -415,6 +415,8 @@ void arm64_notify_segfault(unsigned long addr)
 
 asmlinkage void __exception do_undefinstr(struct pt_regs *regs)
 {
+	oob_trap_notify(ARM64_TRAP_UNDI, regs);
+
 	/* check for AArch32 breakpoint instructions */
 	if (!aarch32_break_handler(regs))
 		return;
@@ -815,6 +817,8 @@ asmlinkage void bad_el0_sync(struct pt_regs *regs, int reason, unsigned int esr)
 {
 	void __user *pc = (void __user *)instruction_pointer(regs);
 
+	oob_trap_notify(ARM64_TRAP_UNDSE, regs);
+
 	current->thread.fault_address = 0;
 	current->thread.fault_code = esr;
 
diff --git a/arch/arm64/mm/fault.c b/arch/arm64/mm/fault.c
index c5c21412b609..7e1b3ff66825 100644
--- a/arch/arm64/mm/fault.c
+++ b/arch/arm64/mm/fault.c
@@ -49,6 +49,7 @@
 #include <asm/pgtable.h>
 #include <asm/tlbflush.h>
 #include <asm/traps.h>
+#include <asm/dovetail.h>
 
 struct fault_info {
 	int	(*fn)(unsigned long addr, unsigned int esr,
@@ -71,6 +72,13 @@ static inline const struct fault_info *esr_to_debug_fault_info(unsigned int esr)
 	return debug_fault_info + DBG_ESR_EVT(esr);
 }
 
+#ifdef CONFIG_DOVETAIL
+#define fault_entry(__exception, __regs)	__fault_entry(__exception, __regs)
+#else
+/* Do not depend on trap id. definitions from asm/dovetail.h */
+#define fault_entry(__exception, __regs)	__fault_entry(-1, __regs)
+#endif
+
 #ifdef CONFIG_IRQ_PIPELINE
 /*
  * We need to synchronize the virtual interrupt state with the hard
@@ -85,11 +93,21 @@ static inline const struct fault_info *esr_to_debug_fault_info(unsigned int esr)
  */
 
 static inline
-unsigned long fault_entry(struct pt_regs *regs)
+unsigned long __fault_entry(unsigned int exception, struct pt_regs *regs)
 {
 	unsigned long flags;
 	int nosync = 1;
 
+	/*
+	 * CAUTION: The co-kernel might demote the current context to
+	 * the in-band stage as a result of handling this trap,
+	 * returning with hard irqs on. Do not propagate SEA traps to
+	 * the co-kernel in NMI mode, there is nothing it could do
+	 * about it.
+	 */
+	if (likely(exception != ARM64_TRAP_SEA || interrupts_enabled(regs)))
+		oob_trap_notify(exception, regs);
+
 	flags = hard_local_irq_save();
 
 	if (hard_irqs_disabled_flags(flags))
@@ -132,7 +150,7 @@ static inline void fault_exit(unsigned long combo)
 #else	/* !CONFIG_IRQ_PIPELINE */
 
 static inline
-unsigned long fault_entry(struct pt_regs *regs)
+unsigned long __fault_entry(unsigned int exception, struct pt_regs *regs)
 {
 	return 0;
 }
@@ -456,7 +474,7 @@ static void do_bad_area(unsigned long addr, unsigned int esr, struct pt_regs *re
 		const struct fault_info *inf = esr_to_fault_info(esr);
 		unsigned long irqflags;
 
-		irqflags = fault_entry(regs);
+		irqflags = fault_entry(ARM64_TRAP_ACCESS, regs);
 		set_thread_esr(addr, esr);
 		arm64_force_sig_fault(inf->sig, inf->code, (void __user *)addr,
 				      inf->name);
@@ -526,7 +544,7 @@ static int __kprobes do_page_fault(unsigned long addr, unsigned int esr,
 	unsigned long vm_flags = VM_READ | VM_WRITE, irqflags;
 	unsigned int mm_flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;
 
-	irqflags = fault_entry(regs);
+	irqflags = fault_entry(ARM64_TRAP_ACCESS, regs);
 
 	if (notify_page_fault(regs, esr))
 		goto out;
@@ -728,7 +746,7 @@ static int do_sea(unsigned long addr, unsigned int esr, struct pt_regs *regs)
 	unsigned long irqflags;
 	void __user *siaddr;
 
-	irqflags = fault_entry(regs);
+	irqflags = fault_entry(ARM64_TRAP_SEA, regs);
 
 	inf = esr_to_fault_info(esr);
 
@@ -825,7 +843,7 @@ asmlinkage void __exception do_mem_abort(unsigned long addr, unsigned int esr,
 	if (!inf->fn(addr, esr, regs))
 		return;
 
-	irqflags = fault_entry(regs);
+	irqflags = fault_entry(ARM64_TRAP_ABRT, regs);
 
 	if (!user_mode(regs)) {
 		pr_alert("Unhandled fault at 0x%016lx\n", addr);
@@ -878,7 +896,7 @@ asmlinkage void __exception do_sp_pc_abort(unsigned long addr,
 		local_daif_restore(DAIF_PROCCTX);
 	}
 
-	irqflags = fault_entry(regs);
+	irqflags = fault_entry(ARM64_TRAP_ABRT, regs);
 
 	arm64_notify_die("SP/PC alignment exception", regs,
 			 SIGBUS, BUS_ADRALN, (void __user *)addr, esr);
@@ -935,7 +953,7 @@ asmlinkage void __exception do_debug_exception(unsigned long addr_if_watchpoint,
 	if (user_mode(regs) && !is_ttbr0_addr(pc))
 		arm64_apply_bp_hardening();
 
-	irqflags = fault_entry(regs);
+	irqflags = fault_entry(ARM64_TRAP_DEBUG, regs);
 
 	if (inf->fn(addr_if_watchpoint, esr, regs)) {
 		arm64_notify_die(inf->name, regs,
-- 
2.16.4

