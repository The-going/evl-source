From a808261ad025ea0e299c5b7d5e59f05a51af9cb3 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Fri, 14 Sep 2018 11:17:29 +0200
Subject: [PATCH] arm64: dovetail: route traps to the co-kernel

Signed-off-by: Philippe Gerum <rpm@xenomai.org>
---
 arch/arm64/include/asm/dovetail.h | 10 ++++++++++
 arch/arm64/kernel/fpsimd.c        |  6 +++++-
 arch/arm64/kernel/ptrace.c        |  2 ++
 arch/arm64/kernel/traps.c         |  4 ++++
 arch/arm64/mm/fault.c             | 34 ++++++++++++++++++++++++++--------
 5 files changed, 47 insertions(+), 9 deletions(-)

diff --git a/arch/arm64/include/asm/dovetail.h b/arch/arm64/include/asm/dovetail.h
index 8c0af9bbf972..c2c0ae6c1e05 100644
--- a/arch/arm64/include/asm/dovetail.h
+++ b/arch/arm64/include/asm/dovetail.h
@@ -6,4 +6,14 @@
 #ifndef _ASM_ARM64_DOVETAIL_H
 #define _ASM_ARM64_DOVETAIL_H
 
+/* ARM64 traps */
+#define ARM64_TRAP_ACCESS	0	/* Data or instruction access exception */
+#define ARM64_TRAP_ABRT		1	/* Memory/alignment abort */
+#define ARM64_TRAP_SEA		2	/* Synchronous external abort */
+#define ARM64_TRAP_DEBUG	3	/* Debug trap */
+#define ARM64_TRAP_UNDI		4	/* Undefined instruction */
+#define ARM64_TRAP_UNDSE	5	/* Undefined synchronous exception */
+#define ARM64_TRAP_FPE		6	/* FPSIMD exception */
+#define ARM64_TRAP_SVE		7	/* SVE access trap */
+
 #endif /* _ASM_ARM64_DOVETAIL_H */
diff --git a/arch/arm64/kernel/fpsimd.c b/arch/arm64/kernel/fpsimd.c
index 3eb338f14386..69abf8a97af3 100644
--- a/arch/arm64/kernel/fpsimd.c
+++ b/arch/arm64/kernel/fpsimd.c
@@ -29,7 +29,7 @@
 #include <linux/stddef.h>
 #include <linux/sysctl.h>
 #include <linux/swab.h>
-
+#include <linux/dovetail.h>
 #include <asm/esr.h>
 #include <asm/fpsimd.h>
 #include <asm/cpufeature.h>
@@ -922,6 +922,8 @@ void fpsimd_release_task(struct task_struct *dead_task)
  */
 void do_sve_acc(unsigned int esr, struct pt_regs *regs)
 {
+	oob_trap_notify(ARM64_TRAP_SVE, regs);
+
 	/* Even if we chose not to use SVE, the hardware could still trap: */
 	if (unlikely(!system_supports_sve()) || WARN_ON(is_compat_task())) {
 		force_signal_inject(SIGILL, ILL_ILLOPC, regs->pc);
@@ -973,6 +975,8 @@ void do_fpsimd_exc(unsigned int esr, struct pt_regs *regs)
 			si_code = FPE_FLTRES;
 	}
 
+	oob_trap_notify(ARM64_TRAP_FPE, regs);
+
 	send_sig_fault(SIGFPE, si_code,
 		       (void __user *)instruction_pointer(regs),
 		       current);
diff --git a/arch/arm64/kernel/ptrace.c b/arch/arm64/kernel/ptrace.c
index 6771c399d40c..25a604e2a494 100644
--- a/arch/arm64/kernel/ptrace.c
+++ b/arch/arm64/kernel/ptrace.c
@@ -174,6 +174,8 @@ static void ptrace_hbptriggered(struct perf_event *bp,
 	struct arch_hw_breakpoint *bkpt = counter_arch_bp(bp);
 	const char *desc = "Hardware breakpoint trap (ptrace)";
 
+	oob_trap_notify(ARM64_TRAP_DEBUG, regs);
+
 #ifdef CONFIG_COMPAT
 	if (is_compat_task()) {
 		int si_errno = 0;
diff --git a/arch/arm64/kernel/traps.c b/arch/arm64/kernel/traps.c
index f42222c49460..cd33f11752cb 100644
--- a/arch/arm64/kernel/traps.c
+++ b/arch/arm64/kernel/traps.c
@@ -396,6 +396,8 @@ void arm64_notify_segfault(unsigned long addr)
 
 void do_undefinstr(struct pt_regs *regs)
 {
+	oob_trap_notify(ARM64_TRAP_UNDI, regs);
+
 	/* check for AArch32 breakpoint instructions */
 	if (!aarch32_break_handler(regs))
 		return;
@@ -810,6 +812,8 @@ void bad_el0_sync(struct pt_regs *regs, int reason, unsigned int esr)
 {
 	void __user *pc = (void __user *)instruction_pointer(regs);
 
+	oob_trap_notify(ARM64_TRAP_UNDSE, regs);
+
 	current->thread.fault_address = 0;
 	current->thread.fault_code = esr;
 
diff --git a/arch/arm64/mm/fault.c b/arch/arm64/mm/fault.c
index 15dab190a19e..d75487b42172 100644
--- a/arch/arm64/mm/fault.c
+++ b/arch/arm64/mm/fault.c
@@ -40,6 +40,7 @@
 #include <asm/pgtable.h>
 #include <asm/tlbflush.h>
 #include <asm/traps.h>
+#include <asm/dovetail.h>
 
 struct fault_info {
 	int	(*fn)(unsigned long addr, unsigned int esr,
@@ -62,6 +63,13 @@ static inline const struct fault_info *esr_to_debug_fault_info(unsigned int esr)
 	return debug_fault_info + DBG_ESR_EVT(esr);
 }
 
+#ifdef CONFIG_DOVETAIL
+#define fault_entry(__exception, __regs)	__fault_entry(__exception, __regs)
+#else
+/* Do not depend on trap id. definitions from asm/dovetail.h */
+#define fault_entry(__exception, __regs)	__fault_entry(-1, __regs)
+#endif
+
 #ifdef CONFIG_IRQ_PIPELINE
 /*
  * We need to synchronize the virtual interrupt state with the hard
@@ -76,11 +84,21 @@ static inline const struct fault_info *esr_to_debug_fault_info(unsigned int esr)
  */
 
 static inline
-unsigned long fault_entry(struct pt_regs *regs)
+unsigned long __fault_entry(unsigned int exception, struct pt_regs *regs)
 {
 	unsigned long flags;
 	int nosync = 1;
 
+	/*
+	 * CAUTION: The co-kernel might demote the current context to
+	 * the in-band stage as a result of handling this trap,
+	 * returning with hard irqs on. Do not propagate SEA traps to
+	 * the co-kernel in NMI mode, there is nothing it could do
+	 * about it.
+	 */
+	if (likely(exception != ARM64_TRAP_SEA || interrupts_enabled(regs)))
+		oob_trap_notify(exception, regs);
+
 	flags = hard_local_irq_save();
 
 	if (hard_irqs_disabled_flags(flags))
@@ -123,7 +141,7 @@ static inline void fault_exit(unsigned long combo)
 #else	/* !CONFIG_IRQ_PIPELINE */
 
 static inline
-unsigned long fault_entry(struct pt_regs *regs)
+unsigned long __fault_entry(unsigned int exception, struct pt_regs *regs)
 {
 	return 0;
 }
@@ -460,7 +478,7 @@ static void do_bad_area(unsigned long addr, unsigned int esr, struct pt_regs *re
 		const struct fault_info *inf = esr_to_fault_info(esr);
 		unsigned long irqflags;
 
-		irqflags = fault_entry(regs);
+		irqflags = fault_entry(ARM64_TRAP_ACCESS, regs);
 		set_thread_esr(addr, esr);
 		arm64_force_sig_fault(inf->sig, inf->code, (void __user *)addr,
 				      inf->name);
@@ -529,7 +547,7 @@ static int __kprobes do_page_fault(unsigned long addr, unsigned int esr,
 	unsigned long vm_flags = VM_READ | VM_WRITE | VM_EXEC, irqflags;
 	unsigned int mm_flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;
 
-	irqflags = fault_entry(regs);
+	irqflags = fault_entry(ARM64_TRAP_ACCESS, regs);
 
 	if (kprobe_page_fault(regs, esr))
 		goto out;
@@ -731,7 +749,7 @@ static int do_sea(unsigned long addr, unsigned int esr, struct pt_regs *regs)
 	unsigned long irqflags;
 	void __user *siaddr;
 
-	irqflags = fault_entry(regs);
+	irqflags = fault_entry(ARM64_TRAP_SEA, regs);
 
 	inf = esr_to_fault_info(esr);
 
@@ -827,7 +845,7 @@ void do_mem_abort(unsigned long addr, unsigned int esr, struct pt_regs *regs)
 	if (!inf->fn(addr, esr, regs))
 		return;
 
-	irqflags = fault_entry(regs);
+	irqflags = fault_entry(ARM64_TRAP_ABRT, regs);
 
 	if (!user_mode(regs)) {
 		pr_alert("Unhandled fault at 0x%016lx\n", addr);
@@ -857,7 +875,7 @@ void do_sp_pc_abort(unsigned long addr, unsigned int esr, struct pt_regs *regs)
 {
 	unsigned long irqflags;
 
-	irqflags = fault_entry(regs);
+	irqflags = fault_entry(ARM64_TRAP_ABRT, regs);
 
 	arm64_notify_die("SP/PC alignment exception", regs,
 			 SIGBUS, BUS_ADRALN, (void __user *)addr, esr);
@@ -988,7 +1006,7 @@ void do_debug_exception(unsigned long addr_if_watchpoint, unsigned int esr,
 	if (user_mode(regs) && !is_ttbr0_addr(pc))
 		arm64_apply_bp_hardening();
 
-	irqflags = fault_entry(regs);
+	irqflags = fault_entry(ARM64_TRAP_DEBUG, regs);
 
 	if (inf->fn(addr_if_watchpoint, esr, regs)) {
 		arm64_notify_die(inf->name, regs,
-- 
2.16.4

