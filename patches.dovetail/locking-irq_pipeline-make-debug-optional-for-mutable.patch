From 8b0db4051b4252fc0d22e0f12fe7edb5d27e59d9 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Sun, 28 Apr 2019 19:37:40 +0200
Subject: [PATCH] locking: irq_pipeline: make debug optional for mutable
 spinlocks

---
 include/linux/spinlock_pipeline.h | 11 ++++-------
 kernel/locking/pipeline.c         | 22 +++++++---------------
 2 files changed, 11 insertions(+), 22 deletions(-)

diff --git a/include/linux/spinlock_pipeline.h b/include/linux/spinlock_pipeline.h
index 57e93847e1c0..dcbc501d7476 100644
--- a/include/linux/spinlock_pipeline.h
+++ b/include/linux/spinlock_pipeline.h
@@ -201,10 +201,9 @@ void __mutable_spin_lock(struct raw_spinlock *rlock);
 
 static inline void mutable_spin_lock(struct raw_spinlock *rlock)
 {
-	if (in_pipeline()) {
+	if (in_pipeline())
 		hard_lock_acquire(rlock, 0, _THIS_IP_);
-		LOCK_CONTENDED(rlock, do_raw_spin_trylock, do_raw_spin_lock);
-	} else
+	else
 		__mutable_spin_lock(rlock);
 }
 
@@ -223,10 +222,9 @@ void __mutable_spin_lock_irq(struct raw_spinlock *rlock);
 
 static inline void mutable_spin_lock_irq(struct raw_spinlock *rlock)
 {
-	if (in_pipeline()) {
+	if (in_pipeline())
 		hard_lock_acquire(rlock, 0, _THIS_IP_);
-		LOCK_CONTENDED(rlock, do_raw_spin_trylock, do_raw_spin_lock);
-	} else
+	else
 		__mutable_spin_lock_irq(rlock);
 }
 
@@ -247,7 +245,6 @@ unsigned long __mutable_spin_lock_irqsave(struct raw_spinlock *rlock);
 	do {								\
 		if (in_pipeline()) {					\
 			hard_lock_acquire(__rlock, 0, _THIS_IP_);	\
-			LOCK_CONTENDED(__rlock, do_raw_spin_trylock, do_raw_spin_lock); \
 			(__flags) = hard_local_save_flags();		\
 		} else							\
 			(__flags) = __mutable_spin_lock_irqsave(__rlock); \
diff --git a/kernel/locking/pipeline.c b/kernel/locking/pipeline.c
index 8cada5d0ca2b..ba16dafe502f 100644
--- a/kernel/locking/pipeline.c
+++ b/kernel/locking/pipeline.c
@@ -38,7 +38,6 @@ void __mutable_spin_lock(struct raw_spinlock *rlock)
 
 	__flags = hard_local_irq_save();
 	hard_lock_acquire(rlock, 0, _RET_IP_);
-	LOCK_CONTENDED(rlock, do_raw_spin_trylock, do_raw_spin_lock);
 	lock = container_of(rlock, struct mutable_spinlock, rlock);
 	lock->hwflags = __flags;
 }
@@ -69,13 +68,11 @@ void __mutable_spin_lock_irq(struct raw_spinlock *rlock)
 
 	if (running_inband()) {
 		set_stage_bit(STAGE_STALL_BIT, this_inband_staged());
-		if (!hard_irqs_disabled_flags(__flags))
-			trace_hardirqs_off();
+		trace_hardirqs_off();
 		preempt_disable();
 	}
 
 	hard_lock_acquire(rlock, 0, _RET_IP_);
-	LOCK_CONTENDED(rlock, do_raw_spin_trylock, do_raw_spin_lock);
 	lock = container_of(rlock, struct mutable_spinlock, rlock);
 	lock->hwflags = __flags;
 }
@@ -92,8 +89,7 @@ void __mutable_spin_unlock_irq(struct raw_spinlock *rlock)
 	do_raw_spin_unlock(rlock);
 
 	if (running_inband()) {
-		if (!hard_irqs_disabled_flags(__flags))
-			trace_hardirqs_on();
+		trace_hardirqs_on();
 		clear_stage_bit(STAGE_STALL_BIT, this_inband_staged());
 		hard_local_irq_restore(__flags);
 		preempt_enable();
@@ -114,13 +110,11 @@ unsigned long __mutable_spin_lock_irqsave(struct raw_spinlock *rlock)
 	if (running_inband()) {
 		flags = test_and_set_stage_bit(STAGE_STALL_BIT,
 				       this_inband_staged());
-		if (!hard_irqs_disabled_flags(__flags))
-			trace_hardirqs_off();
+		trace_hardirqs_off();
 		preempt_disable();
 	}
 
 	hard_lock_acquire(rlock, 0, _RET_IP_);
-	LOCK_CONTENDED(rlock, do_raw_spin_trylock, do_raw_spin_lock);
 	lock = container_of(rlock, struct mutable_spinlock, rlock);
 	lock->hwflags = __flags;
 
@@ -141,8 +135,7 @@ void __mutable_spin_unlock_irqrestore(struct raw_spinlock *rlock,
 
 	if (running_inband()) {
 		if (!flags) {
-			if (!hard_irqs_disabled_flags(__flags))
-				trace_hardirqs_on();
+			trace_hardirqs_on();
 			clear_stage_bit(STAGE_STALL_BIT,
 					this_inband_staged());
 		}
@@ -168,7 +161,7 @@ int __mutable_spin_trylock(struct raw_spinlock *rlock)
 
 	if (do_raw_spin_trylock(rlock)) {
 		lock->hwflags = __flags;
-		hard_lock_acquire(rlock, 1, _RET_IP_);
+		hard_trylock_acquire(rlock, 1, _RET_IP_);
 		return 1;
 	}
 
@@ -197,13 +190,12 @@ int __mutable_spin_trylock_irqsave(struct raw_spinlock *rlock,
 	lock = container_of(rlock, struct mutable_spinlock, rlock);
 	if (inband) {
 		*flags = test_and_set_stage_bit(STAGE_STALL_BIT, p);
-		if (!hard_irqs_disabled_flags(__flags))
-			trace_hardirqs_off();
+		trace_hardirqs_off();
 		preempt_disable();
 	}
 
 	if (do_raw_spin_trylock(rlock)) {
-		hard_lock_acquire(rlock, 1, _RET_IP_);
+		hard_trylock_acquire(rlock, 1, _RET_IP_);
 		lock->hwflags = __flags;
 		return 1;
 	}
-- 
2.16.4

