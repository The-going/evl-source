From ebf953eeb4a6e3e3be239a3933ab7a6e015666c5 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Thu, 21 Jul 2016 21:04:43 +0200
Subject: [PATCH] dovetail: add core support

This is the basic interface layer for hosting a high-priority resident
co-kernel, aka "dovetailing".

The co-kernel leverages the interrupt pipeline ability to turn common
device IRQs into pseudo-NMIs from the perspective of the in-band code
(CONFIG_IRQ_PIPELINE), to achieve very low latency for the co-kernel
running on the oob stage.
---
 Documentation/dovetail.rst     | 352 +++++++++++++++++++++++++++++++++++++++++
 include/dovetail/mm_info.h     |  12 ++
 include/dovetail/thread_info.h |  13 ++
 include/linux/dovetail.h       | 141 +++++++++++++++++
 include/linux/mm_types.h       |   4 +
 kernel/Kconfig.dovetail        |  14 ++
 kernel/Makefile                |   1 +
 kernel/dovetail.c              | 225 ++++++++++++++++++++++++++
 kernel/irq/pipeline.c          |  14 ++
 kernel/sched/sched.h           |   1 +
 lib/Kconfig.debug              |  10 ++
 11 files changed, 787 insertions(+)
 create mode 100644 Documentation/dovetail.rst
 create mode 100644 include/dovetail/mm_info.h
 create mode 100644 include/dovetail/thread_info.h
 create mode 100644 include/linux/dovetail.h
 create mode 100644 kernel/Kconfig.dovetail
 create mode 100644 kernel/dovetail.c

diff --git a/Documentation/dovetail.rst b/Documentation/dovetail.rst
new file mode 100644
index 00000000000..34ed15c2a88
--- /dev/null
+++ b/Documentation/dovetail.rst
@@ -0,0 +1,352 @@
+========================
+Introduction to Dovetail
+========================
+
+:Copyright: |copy| 2016-2018: Philippe Gerum
+
+Using Linux as a host for lightweight software cores specialized in
+delivering very short and bounded response times has been a popular
+way of supporting real-time applications in the embedded space over
+the years.
+
+This design - known as the *dual kernel* approach - introduces a small
+real-time infrastructure which schedules time-critical activities
+independently from the main kernel. Application threads co-managed by
+this infrastructure still benefit from the ancillary kernel services
+such as virtual memory management, and can also leverage the rich GPOS
+feature set Linux provides such as networking, data storage or GUIs.
+
+There are significant upsides to keeping the real-time core separate
+from the GPOS infrastructure:
+
+- because the two kernels are independent, real-time activities are
+  not serialized with GPOS operations internally, removing potential
+  delays which might be induced by the non time-critical
+  work. Likewise, there is no requirement for keeping the GPOS
+  operations fine-grained and highly preemptible at any time, which
+  would otherwise induce noticeable overhead on low-end hardware, due
+  to the need for pervasive task priority inheritance and IRQ
+  threading.
+
+- when debugging a real-time issue, the functional isolation of the
+  real-time infrastructure from the rest of the kernel code restricts
+  bug hunting to the scope of the small co-kernel, excluding most
+  interactions with the very large GPOS kernel base.
+
+- with a dedicated infrastructure providing a specific, well-defined
+  set of real-time services, applications can unambiguously figure out
+  which API calls are available for supporting time-critical work,
+  excluding all the rest as being potentially non-deterministic with
+  respect to response time.
+
+To support such a *dual kernel system*, we need the kernel to exhibit
+a high-priority execution context, for running out-of-band real-time
+duties concurrently to the regular operations.
+
+.. NOTE:: Dovetail only introduces the basic mechanisms for hosting
+such a real-time core, enabling the common programming model for its
+applications in user-space. It does *not* implement the real-time core
+per se, which should be provided by a separate kernel component.
+
+Interrupt pipelining
+====================
+
+.. _pipeline
+The real-time core has to act upon device interrupts with no delay,
+regardless of the regular kernel operations which may be ongoing when
+the interrupt is received by the CPU. Therefore, there is a basic
+requirement for prioritizing interrupt masking and delivery between
+the real-time core and GPOS operations, while maintaining consistent
+internal serialization for the kernel.
+
+To this end, Dovetail leverages a mechanism called *interrupt
+pipelining*, which is described in the
+:ref:`Documentation/irq_pipeline.rst <Interrupt Pipeline>`)
+document. Understanding the concepts and mechanisms described in the
+later document is required for a full comprehension of the Dovetail
+basics.
+
+Alternate scheduling
+====================
+
+Dovetail promotes the idea that a *dual kernel* system should keep the
+functional overlap between the kernel and the real-time core
+minimal. To this end, a real-time thread should be merely seen as a
+regular task with additional scheduling capabilities guaranteeing very
+low response times.
+
+To support such idea, Dovetail enables kthreads and regular user tasks
+to run alternatively in the out-of-band execution context introduced
+by the interrupt pipeline_ (aka *oob* stage), or the common in-band
+kernel context for GPOS operations (aka *in-band* stage).
+
+As a result, real-time core applications in user-space benefit from
+the common Linux programming model - including virtual memory
+protection -, and still have access to the regular Linux services when
+carrying out non time-critical work.
+
+Task migration to the oob stage
+-------------------------------
+
+Low latency response time to events can be achieved when Linux tasks
+wait for them from the out-of-band execution context. The real-time
+core is responsible for switching a task to such a context as part of
+its task management rules; Dovetail facilitates this migration with
+dedicated services.
+
+The migration process of a task from the GPOS/in-band context to the
+high-priority, out-of-band context is as follows:
+
+1. :c:func:`dovetail_leave_inband` is invoked from the migrating task
+   context, with the same prerequisites than for calling
+   :c:func:`schedule` (preemption enabled, interrupts on).
+
+.. _`in-band sleep operation`:
+2. the caller is put to interruptible sleep state (S).
+
+3. before resuming in-band operations, the next task picked by the
+   (regular kernel) scheduler on the same CPU for replacing the
+   migrating task fires :c:func:`resume_oob_task` which the
+   real-time core should override (*__weak* binding). Before the call,
+   the oob stage is stalled, interrupts are disabled in the CPU. The
+   in-band execution stage is still current though.
+
+4. the real-time core's implementation of
+   :c:func:`resume_oob_task` is passed a pointer to the
+   task_struct descriptor of the migrating task. This routine is expected
+   to perform the necessary steps for taking control over the task on
+   behalf of the real-time core, re-scheduling its code appropriately
+   over the oob stage. This typically involves resuming it from the
+   `out-of-band suspended state`_ applied during the converse migration
+   path. The real-time core is expected to call :c:func:`dovetail_resume_oob`
+   before transitioning from the inband task context its preempts to any
+   out-of-band thread.
+
+5. at some point later, when the migrated task is picked by the
+   real-time scheduler, it resumes execution on the oob stage with the
+   register file previously saved by the kernel scheduler in
+   :c:func:`switch_to` at step 1.
+
+Task migration to the in-band stage
+-----------------------------------
+
+Sometimes, a real-time thread may want to leave the out-of-band
+context, continuing execution from the in-band context instead, so as
+to:
+
+- run non time-critical (in-band) work involving regular system calls
+  handled by the kernel,
+
+- recover from CPU exceptions, such as handling major memory access
+  faults, for which there is no point in caring for response time, and
+  therefore makes no sense to duplicate in the real-time core anyway.
+
+.. NOTE: The discussion about exception_ handling covers the last
+   point in details.
+
+The migration process of a task from the high-priority, out-of-band
+context to the GPOS/in-band context is as follows::
+
+1. the real-time core schedules an in-band handler for execution which
+   should call :c:func:`wake_up_process` to unblock the migrating task
+   from the standpoint of the kernel scheduler. This is the
+   counterpart of the :ref:`in-band sleep operation <in-band sleep
+   operation>` from the converse migration path. The
+   :ref:`Documentation/irq_pipeline.rst` <irq_work> mechanism can be
+   used for scheduling such event from the out-of-band context.
+
+.. _`out-of-band suspended state`:
+2. the real-time core suspends execution of the current task from its
+   own standpoint, calling :c:func:`dovetail_leave_oob` right before
+   scheduling out the task. The real-time scheduler is assumed to be
+   using the common :c:func:`switch_to` routine for switching task
+   contexts.
+
+3. at some point later, the out-of-band context is exited by the
+   current CPU when no more high-priority work is left, causing the
+   preempted in-band kernel code to resume execution on the in-band
+   stage. The handler scheduled at step 1 eventually runs, waking up
+   the migrating task from the standpoint of the kernel.
+
+4. the migrating task resumes from the tail scheduling code of the
+   real-time scheduler, where it suspended in step 2. Noticing the
+   migration, the real-time core eventually calls
+   :c:func:`dovetail_resume_inband` for finalizing the transition of
+   the incoming task to the in-band stage.
+
+Binding to the real-time core
+-----------------------------
+
+.. _binding:
+Dovetail facilitates fine-grained per-thread management from the
+real-time core, as opposed to per-process. For this reason, the
+real-time core should at least implement a mechanism for turning a
+regular task into a real-time thread with extended capabilities,
+binding it to the core.
+
+The real-time core should inform the kernel about its intent to share
+control over a task, by calling :c:func::`dovetail_start_altsched` on
+behalf of that task, i.e. when such task is current.
+
+For this reason, the binding operation is usually carried out by a
+dedicated system call exposed by the real-time core, which a regular
+task would invoke.
+
+Once :c:func::`dovetail_start_altsched` has returned, Dovetail
+notifications are enabled for the current task (see below).
+
+.. NOTE:: Whether there should be distinct procedures for binding
+	  processes *and* threads to the real-time core, or only a
+	  thread binding procedure is up to the real-time core
+	  implementation.
+
+Notifications
+-------------
+
+Exception handling
+~~~~~~~~~~~~~~~~~~
+
+.. _exception
+If a processor exception is raised while the CPU is busy running a
+real-time thread in the out-of-band context (e.g. due to some invalid
+memory access, bad instruction, FPU or alignment error etc), the task
+may have to leave such context immediately if the fault handler is not
+protected against out-of-band interrupts, and therefore cannot be
+properly serialized with out-of-band code.
+
+Dovetail notifies the real-time core about incoming exceptions early
+from the low-level fault handlers, but only when some out-of-band code
+was running when the exception was taken. The real-time core may then
+take action, such as reconciling the current task's execution context
+with the kernel's expectations before the task may traverse the
+regular fault handling code.
+
+.. HINT:: Enabling debuggers to trace real-time thread involves
+          dealing with debug traps the former may poke into the
+          debuggee's code for breakpointing duties.
+
+The notification is issued by a call to :c:func:`oob_trap_notify`
+which in turn invokes the :c:func:`handle_oob_trap` routine the
+real-time core should override for receiving those events (*__weak*
+binding). Interrupts are **disabled** in the CPU when
+:c:func:`handle_oob_trap` is called.::
+
+     /* out-of-band code running */
+     *bad_pointer = 42;
+        [ACCESS EXCEPTION]
+	   /* low-level fault handler in arch/<arch>/mm */
+           -> do_page_fault()
+	      -> oob_trap_notify(...)
+	         /* real-time core */
+	         -> handle_oob_trap(...)
+		    -> forced task migration to in-band stage
+	   ...
+           -> handle_mm_fault()
+
+.. NOTE:: handling minor memory access faults only requiring quick PTE
+          fixups should not involve switching the current task to the
+          in-band context though. Instead, the fixup code should be
+          made :ref:`Documentation/irq_pipeline.rst` strictly <atomic>
+          for serializing accesses from any context.
+
+System calls
+~~~~~~~~~~~~
+
+A real-time core interfaced with the kernel via Dovetail may introduce
+its own set of system calls. From the standpoint of the kernel, this
+is a foreign set of calls, which can be distinguished unambiguously
+from regular ones based on an arch-specific marker.
+
+.. HINT:: Syscall numbers from this set might have a different base,
+	  and/or some high-order bit set which regular syscall numbers
+	  would not have.
+
+If a task bound to the real-time core issues any system call,
+regardless of which of the kernel or real-time core should handle it,
+the latter must be given the opportunity to:
+
+- perform the service directly, possibly switching the caller to
+  out-of-band context first would the request require it.
+
+- pass the request downward to the normal system call path on the
+  in-band stage, possibly switching the caller to in-band context if
+  needed.
+
+If a regular task (i.e. *not* known from the real-time core [yet])
+issues any foreign system call, the real-time core is given a chance
+to handle it. This way, a foreign system call which would initially
+bind a regular task to the real-time core would be delivered to the
+real-time core as expected (see binding_).
+
+Dovetail intercepts system calls early in the kernel entry code,
+delivering them to the proper handler according to the following
+logic::
+
+     is_foreign(syscall_nr)?
+	    Y: is_bound(task)
+	           Y: -> handle_oob_syscall()
+		   N: -> handle_pipelined_syscall()
+            N: is_bound(task)
+	           Y: -> handle_pipelined_syscall()
+		   N: -> normal syscall handling
+
+:c:func:`handle_oob_syscall` is the fast path for handling foreign
+system calls from tasks already running in out-of-band context.
+
+:c:func:`handle_pipelined_syscall` is a slower path for handling requests
+which might require the caller to switch to the out-of-band context
+first before proceeding.
+
+In-band kernel events
+~~~~~~~~~~~~~~~~~~~~~
+
+The last set of notifications involves pure in-band events which the
+real-time core may need to know about, as they may affect its own task
+management. Except for INBAND_PROCESS_CLEANUP which is called for
+*any* exiting user-space task, all other notifications are only issued
+for tasks bound to the real-time core (which may involve kthreads).
+
+The notification is issued by a call to :c:func:`inband_event_notify`
+which in turn invokes the :c:func:`handle_inband_event` routine the
+real-time core should override for receiving those events (*__weak*
+binding). Interrupts are **enabled** in the CPU when
+:c:func:`handle_inband_event` is called.
+
+The notification hook is given the event type code, and a single
+pointer argument which relates to the event type.
+
+The following events are defined (include/linux/dovetail.h):
+
+- INBAND_TASK_SCHEDULE(struct task_struct *next)
+
+  sent in preparation of a context switch, right before the memory
+  context is switched to *next*.
+
+- INBAND_TASK_SIGNAL(struct task_struct *target)
+
+  sent when *target* is about to receive a signal. The real-time core
+  may decide to schedule a transition of the recipient to the in-band
+  stage in order to have it handle that signal asap, which is required
+  for keeping the kernel sane. This notification is always sent from
+  the context of the issuer.
+
+- INBAND_TASK_MIGRATION(struct dovetail_migration_data *p)
+
+  sent when p->task is about to move to CPU p->dest_cpu.
+
+- INBAND_TASK_EXIT(struct task_struct *current)
+
+  sent from :c:func:`do_exit` before the current task has dropped the
+  files and mappings it owns.
+
+- INBAND_PROCESS_CLEANUP(struct mm_struct *mm)
+
+  sent before *mm* is entirely dropped, before the mappings are
+  exited. Per-process resources which might be maintained by the
+  real-time core could be released there, as all threads have exited.
+
+Terminology
+===========
+
+See the :ref:`Documentation/irq_pipeline.rst` <Interrupt Pipeline
+terminology>.
diff --git a/include/dovetail/mm_info.h b/include/dovetail/mm_info.h
new file mode 100644
index 00000000000..504bd1d875d
--- /dev/null
+++ b/include/dovetail/mm_info.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _DOVETAIL_MM_INFO_H
+#define _DOVETAIL_MM_INFO_H
+
+/*
+ * Placeholder for per-mm state information defined by the co-kernel.
+ */
+
+struct oob_mm_state {
+};
+
+#endif /* !_DOVETAIL_MM_INFO_H */
diff --git a/include/dovetail/thread_info.h b/include/dovetail/thread_info.h
new file mode 100644
index 00000000000..4dea8bf1ecf
--- /dev/null
+++ b/include/dovetail/thread_info.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _DOVETAIL_THREAD_INFO_H
+#define _DOVETAIL_THREAD_INFO_H
+
+/*
+ * Placeholder for per-thread state information defined by the
+ * co-kernel.
+ */
+
+struct oob_thread_state {
+};
+
+#endif /* !_DOVETAIL_THREAD_INFO_H */
diff --git a/include/linux/dovetail.h b/include/linux/dovetail.h
new file mode 100644
index 00000000000..a2f6e7b54bf
--- /dev/null
+++ b/include/linux/dovetail.h
@@ -0,0 +1,141 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2016 Philippe Gerum  <rpm@xenomai.org>.
+ */
+#ifndef _LINUX_DOVETAIL_H
+#define _LINUX_DOVETAIL_H
+
+#ifdef CONFIG_DOVETAIL
+
+#include <linux/sched.h>
+#include <linux/thread_info.h>
+#include <asm/dovetail.h>
+
+struct pt_regs;
+struct task_struct;
+
+enum inband_event_type {
+	INBAND_TASK_SCHEDULE,
+	INBAND_TASK_SIGNAL,
+	INBAND_TASK_MIGRATION,
+	INBAND_TASK_EXIT,
+	INBAND_PROCESS_CLEANUP,
+};
+
+struct dovetail_migration_data {
+	struct task_struct *task;
+	int dest_cpu;
+};
+
+int pipeline_syscall(struct thread_info *ti,
+		     unsigned long syscall, struct pt_regs *regs);
+
+void __oob_trap_notify(unsigned int trapnr,
+		       struct pt_regs *regs);
+
+static inline void oob_trap_notify(unsigned int trapnr,
+				   struct pt_regs *regs)
+{
+	if (running_oob())
+		__oob_trap_notify(trapnr, regs);
+}
+
+void inband_event_notify(enum inband_event_type,
+			 void *data);
+
+static inline void inband_signal_notify(struct task_struct *p)
+{
+	if (test_ti_local_flags(task_thread_info(p), _TLF_DOVETAIL))
+		inband_event_notify(INBAND_TASK_SIGNAL, p);
+}
+
+static inline void inband_migration_notify(struct task_struct *p, int cpu)
+{
+	if (test_ti_local_flags(task_thread_info(p), _TLF_DOVETAIL)) {
+		struct dovetail_migration_data d = {
+			.task = p,
+			.dest_cpu = cpu,
+		};
+		inband_event_notify(INBAND_TASK_MIGRATION, &d);
+	}
+}
+
+static inline void inband_exit_notify(void)
+{
+	if (test_thread_local_flags(_TLF_DOVETAIL))
+		inband_event_notify(INBAND_TASK_EXIT, NULL);
+}
+
+static inline void inband_cleanup_notify(struct mm_struct *mm)
+{
+	/*
+	 * Notify regardless of _TLF_DOVETAIL: current may have
+	 * resources to clean up although it might not be interested
+	 * in other kernel events.
+	 */
+	inband_event_notify(INBAND_PROCESS_CLEANUP, mm);
+}
+
+void sync_inband_irqs(void);
+
+int dovetail_start(void);
+
+void dovetail_stop(void);
+
+static inline
+struct oob_thread_state *dovetail_current_state(void)
+{
+	return &current_thread_info()->oob_state;
+}
+
+static inline
+struct oob_thread_state *dovetail_task_state(struct task_struct *p)
+{
+	return &task_thread_info(p)->oob_state;
+}
+
+void dovetail_call_mayday(struct thread_info *ti,
+			  struct pt_regs *regs);
+
+static inline void dovetail_send_mayday(struct task_struct *castaway)
+{
+	struct thread_info *ti = task_thread_info(castaway);
+
+	if (test_ti_local_flags(ti, _TLF_DOVETAIL))
+		set_ti_thread_flag(ti, TIF_MAYDAY);
+}
+
+#else	/* !CONFIG_DOVETAIL */
+
+#define oob_trap_notify(__trapnr, __regs)	 do { } while (0)
+
+static inline
+int pipeline_syscall(struct thread_info *ti,
+		     unsigned long syscall, struct pt_regs *regs)
+{
+	return 0;
+}
+
+static inline void inband_signal_notify(struct task_struct *p) { }
+
+static inline
+void inband_migration_notify(struct task_struct *p, int cpu) { }
+
+static inline void inband_exit_notify(void) { }
+
+static inline void inband_cleanup_notify(struct mm_struct *mm) { }
+
+#endif	/* !CONFIG_DOVETAIL */
+
+static inline bool dovetailing(void)
+{
+	return IS_ENABLED(CONFIG_DOVETAIL);
+}
+
+static inline bool dovetail_debug(void)
+{
+	return IS_ENABLED(CONFIG_DEBUG_DOVETAIL);
+}
+
+#endif /* _LINUX_DOVETAIL_H */
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index 2c471a2c43f..e52fed13017 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -14,6 +14,7 @@
 #include <linux/uprobes.h>
 #include <linux/page-flags-layout.h>
 #include <linux/workqueue.h>
+#include <dovetail/mm_info.h>
 
 #include <asm/mmu.h>
 
@@ -489,6 +490,9 @@ struct mm_struct {
 		struct uprobes_state uprobes_state;
 #ifdef CONFIG_HUGETLB_PAGE
 		atomic_long_t hugetlb_usage;
+#endif
+#ifdef CONFIG_DOVETAIL
+		struct oob_mm_state oob_state;
 #endif
 		struct work_struct async_put_work;
 
diff --git a/kernel/Kconfig.dovetail b/kernel/Kconfig.dovetail
new file mode 100644
index 00000000000..adc6922d64e
--- /dev/null
+++ b/kernel/Kconfig.dovetail
@@ -0,0 +1,14 @@
+
+# DOVETAIL co-kernel interface
+config HAVE_DOVETAIL
+	bool
+
+config DOVETAIL
+	bool "Dovetail interface"
+	depends on HAVE_DOVETAIL
+	select IRQ_PIPELINE
+	default n
+	---help---
+	  Activate this option if you want to enable the interface for
+	  running a secondary kernel side-by-side with Linux (aka
+	  "dual kernel" configuration).
diff --git a/kernel/Makefile b/kernel/Makefile
index 6aa7543bcdb..f2efe30bc88 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -96,6 +96,7 @@ obj-$(CONFIG_TRACE_CLOCK) += trace/
 obj-$(CONFIG_RING_BUFFER) += trace/
 obj-$(CONFIG_TRACEPOINTS) += trace/
 obj-$(CONFIG_IRQ_WORK) += irq_work.o
+obj-$(CONFIG_DOVETAIL) += dovetail.o
 obj-$(CONFIG_CPU_PM) += cpu_pm.o
 obj-$(CONFIG_BPF) += bpf/
 
diff --git a/kernel/dovetail.c b/kernel/dovetail.c
new file mode 100644
index 00000000000..05bc5c0d735
--- /dev/null
+++ b/kernel/dovetail.c
@@ -0,0 +1,225 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2016 Philippe Gerum  <rpm@xenomai.org>.
+ */
+#include <linux/timekeeper_internal.h>
+#include <linux/sched/signal.h>
+#include <linux/irq_pipeline.h>
+#include <linux/dovetail.h>
+#include <asm/unistd.h>
+#include <asm/syscall.h>
+
+static bool dovetail_enabled;
+
+void __weak handle_oob_syscall(struct pt_regs *regs)
+{
+}
+
+int __weak handle_pipelined_syscall(struct irq_stage *stage,
+				    struct pt_regs *regs)
+{
+	return 0;
+}
+
+void __weak handle_oob_mayday(struct pt_regs *regs)
+{
+}
+
+static inline
+void call_mayday(struct thread_info *ti, struct pt_regs *regs)
+{
+	clear_ti_thread_flag(ti, TIF_MAYDAY);
+	handle_oob_mayday(regs);
+}
+
+void dovetail_call_mayday(struct thread_info *ti, struct pt_regs *regs)
+{
+	unsigned long flags;
+
+	flags = hard_local_irq_save();
+	call_mayday(ti, regs);
+	hard_local_irq_restore(flags);
+}
+
+int __pipeline_syscall(struct thread_info *ti, struct pt_regs *regs)
+{
+	struct irq_stage *caller_stage, *target_stage;
+	struct irq_stage_data *p, *this_context;
+	unsigned long flags;
+	int ret = 0;
+
+	/*
+	 * We should definitely not pipeline a syscall through the
+	 * slow path with IRQs off.
+	 */
+	WARN_ON_ONCE(dovetail_debug() && hard_irqs_disabled());
+
+	if (!dovetail_enabled)
+		return 0;
+
+	flags = hard_local_irq_save();
+	caller_stage = current_stage;
+	this_context = current_staged;
+	target_stage = &oob_stage;
+next:
+	p = this_staged(target_stage);
+	set_current_staged(p);
+	hard_local_irq_restore(flags);
+	ret = handle_pipelined_syscall(caller_stage, regs);
+	flags = hard_local_irq_save();
+	/*
+	 * Be careful about stage switching _and_ CPU migration that
+	 * might have happened as a result of handing over the syscall
+	 * to the out-of-band handler.
+	 *
+	 * - if a stage migration is detected, fetch the new
+	 * per-stage, per-CPU context pointer.
+	 *
+	 * - if no stage migration happened, switch back to the
+	 * initial caller's stage, on a possibly different CPU though.
+	 */
+	if (current_stage != target_stage)
+		this_context = current_staged;
+	else {
+		p = this_staged(this_context->stage);
+		set_current_staged(p);
+	}
+
+	if (this_context->stage == &inband_stage) {
+		if (target_stage != &inband_stage && ret == 0) {
+			target_stage = &inband_stage;
+			goto next;
+		}
+		p = this_inband_staged();
+		if (stage_irqs_pending(p))
+			sync_current_stage();
+	} else if (test_ti_thread_flag(ti, TIF_MAYDAY))
+		call_mayday(ti, regs);
+
+	hard_local_irq_restore(flags);
+
+	return ret;
+}
+
+void sync_inband_irqs(void)
+{
+	struct irq_stage_data *p;
+	unsigned long flags;
+
+	flags = hard_local_irq_save();
+
+	p = this_inband_staged();
+	if (stage_irqs_pending(p))
+		sync_current_stage();
+
+	hard_local_irq_restore(flags);
+}
+
+int pipeline_syscall(struct thread_info *ti,
+		     unsigned long nr, struct pt_regs *regs)
+{
+	unsigned long local_flags = READ_ONCE(ti_local_flags(ti));
+	int ret;
+
+	/*
+	 * If the syscall number is out of bounds and we are not
+	 * running in-band, this has to be a non-native system call
+	 * handled by some co-kernel from the oob stage. Hand it over
+	 * via the fast syscall handler.
+	 *
+	 * Otherwise, if the system call is out of bounds or alternate
+	 * scheduling is enabled for the current thread, propagate the
+	 * syscall through the pipeline stages. This allows:
+	 *
+	 * - the co-kernel to receive any initial - foreign - syscall
+	 * a thread should send for enabling dovetailing from the
+	 * in-band stage.
+	 *
+	 * - the co-kernel to manipulate the current execution stage
+	 * for handling the request, which includes switching the
+	 * current thread back to the in-band context if the syscall
+	 * is a native one, or promoting it to the oob stage if
+	 * handling a foreign syscall requires this.
+	 *
+	 * Native syscalls from common (non-dovetailed) threads are
+	 * ignored by this routine, flowing down to the in-band system
+	 * call handler.
+	 */
+
+	if (nr >= NR_syscalls && (local_flags & _TLF_OOB)) {
+		handle_oob_syscall(regs);
+		local_flags = READ_ONCE(ti_local_flags(ti));
+		if (local_flags & _TLF_OOB) {
+			if (test_ti_thread_flag(ti, TIF_MAYDAY))
+				dovetail_call_mayday(ti, regs);
+			return 1; /* don't pass down, no tail work. */
+		} else {
+			sync_inband_irqs();
+			return -1; /* don't pass down, do tail work. */
+		}
+	}
+
+	if ((local_flags & _TLF_DOVETAIL) || nr >= NR_syscalls) {
+		ret = __pipeline_syscall(ti, regs);
+		local_flags = READ_ONCE(ti_local_flags(ti));
+		if (local_flags & _TLF_OOB)
+			return 1; /* don't pass down, no tail work. */
+		if (ret)
+			return -1; /* don't pass down, do tail work. */
+	}
+
+	return 0; /* pass syscall down to the host. */
+}
+
+void __weak handle_oob_trap(unsigned int trapnr, struct pt_regs *regs)
+{
+}
+
+void __oob_trap_notify(unsigned int exception, struct pt_regs *regs)
+{
+	/*
+	 * We send a notification about all traps raised over a
+	 * registered oob stage only.
+	 */
+	if (dovetail_enabled)
+		handle_oob_trap(exception, regs);
+}
+
+void __weak handle_inband_event(enum inband_event_type event, void *data)
+{
+}
+
+void inband_event_notify(enum inband_event_type event, void *data)
+{
+	check_inband_stage();
+
+	if (dovetail_enabled)
+		handle_inband_event(event, data);
+}
+
+int dovetail_start(void)
+{
+	check_inband_stage();
+
+	if (dovetail_enabled)
+		return -EBUSY;
+
+	if (!oob_stage_present())
+		return -EAGAIN;
+
+	dovetail_enabled = true;
+	smp_wmb();
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dovetail_start);
+
+void dovetail_stop(void)
+{
+	check_inband_stage();
+
+	dovetail_enabled = false;
+	smp_wmb();
+}
+EXPORT_SYMBOL_GPL(dovetail_stop);
diff --git a/kernel/irq/pipeline.c b/kernel/irq/pipeline.c
index 415585a6d1b..74bc3b092e6 100644
--- a/kernel/irq/pipeline.c
+++ b/kernel/irq/pipeline.c
@@ -10,6 +10,7 @@
 #include <linux/irqdomain.h>
 #include <linux/irq_pipeline.h>
 #include <linux/irq_work.h>
+#include <linux/dovetail.h>
 #include <trace/events/irq.h>
 #include "internals.h"
 
@@ -743,6 +744,18 @@ void __weak enter_oob_irq(void) { }
 
 void __weak exit_oob_irq(void) { }
 
+static inline void check_pending_mayday(struct pt_regs *regs)
+{
+#ifdef CONFIG_DOVETAIL
+	/*
+	 * Sending MAYDAY is in essence a rare case, so prefer test
+	 * then maybe clear over test_and_clear.
+	 */
+	if (user_mode(regs) && test_thread_flag(TIF_MAYDAY))
+		dovetail_call_mayday(current_thread_info(), regs);
+#endif
+}
+
 static inline
 irqreturn_t __call_action_handler(struct irqaction *action,
 				  struct irq_desc *desc)
@@ -1011,6 +1024,7 @@ int generic_pipeline_irq(unsigned int irq, struct pt_regs *regs)
 	 */
 	exit_oob_irq();
 	synchronize_pipeline_on_irq();
+	check_pending_mayday(regs);
 	trace_irq_pipeline_exit(irq);
 out:
 	set_irq_regs(old_regs);
diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h
index 3044627c122..6f79206e085 100644
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -53,6 +53,7 @@
 #include <linux/migrate.h>
 #include <linux/mmu_context.h>
 #include <linux/irq_pipeline.h>
+#include <linux/dovetail.h>
 #include <linux/nmi.h>
 #include <linux/proc_fs.h>
 #include <linux/prefetch.h>
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index db628841a63..9b54b3817db 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -827,6 +827,16 @@ config IRQ_PIPELINE_TORTURE_TEST
 	  Say Y here if you want the IRQ pipeline torture tests to run
 	  when the kernel starts. Say N if you are unsure.
 
+config DEBUG_DOVETAIL
+	bool "Debug Dovetail interface"
+	depends on DOVETAIL
+	select DEBUG_IRQ_PIPELINE
+	---help---
+	  Turn on this option for enabling debug checks related to
+	  running a dual kernel configuration, aka dovetailing. This
+	  option implicitly enables the interrupt pipeline debugging
+	  features.
+
 menu "Debug Lockups and Hangs"
 
 config LOCKUP_DETECTOR
-- 
2.16.4

