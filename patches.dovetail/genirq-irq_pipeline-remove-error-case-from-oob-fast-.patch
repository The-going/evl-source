From 1d404967108c4d091ab8dfa32aee3ff3c556ef07 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Mon, 22 Jul 2019 20:34:33 +0200
Subject: [PATCH] genirq: irq_pipeline: remove error case from oob fast path

Signed-off-by: Philippe Gerum <rpm@xenomai.org>
---
 kernel/irq/pipeline.c | 42 ++++++++++++++++++++++++++++--------------
 1 file changed, 28 insertions(+), 14 deletions(-)

diff --git a/kernel/irq/pipeline.c b/kernel/irq/pipeline.c
index 72a8c6f84e51..94bddebe7ec2 100644
--- a/kernel/irq/pipeline.c
+++ b/kernel/irq/pipeline.c
@@ -912,16 +912,15 @@ static void dispatch_oob_irq(struct irq_desc *desc) /* hardirqs off */
 {
 	struct irq_stage_data *oobd = this_oob_staged(), *prevd;
 
-	if (unlikely(test_stage_bit(STAGE_STALL_BIT, oobd))) {
-		irq_post_stage(&oob_stage, irq_desc_get_irq(desc));
-		/*
-		 * Running with the oob stage stalled implies hardirqs
-		 * off, so we should have never gotten here for
-		 * handling an external IRQ in the first place.
-		 */
-		WARN_ON_ONCE(irq_pipeline_debug() && on_pipeline_entry());
+	/*
+	 * Running with the oob stage stalled implies hardirqs off, so
+	 * we should have never gotten here for handling an external
+	 * IRQ in the first place.
+	 */
+	if (WARN_ON_ONCE(irq_pipeline_debug() &&
+				on_pipeline_entry() &&
+				test_stage_bit(STAGE_STALL_BIT, oobd)))
 		return;
-	}
 
 	/* Switch to the oob stage if not current. */
 	prevd = current_irq_staged;
@@ -1072,6 +1071,7 @@ int generic_pipeline_irq(unsigned int irq, struct pt_regs *regs)
  */
 int irq_inject_pipeline(unsigned int irq)
 {
+	struct irq_stage_data *oobd;
 	struct irq_desc *desc;
 	unsigned long flags;
 
@@ -1080,11 +1080,25 @@ int irq_inject_pipeline(unsigned int irq)
 		return -EINVAL;
 
 	flags = hard_local_irq_save();
-	irq_enter_pipeline();
-	handle_oob_irq(desc);
-	irq_exit_pipeline();
-	incr_irq_kstat(desc);
-	synchronize_pipeline_on_irq();
+
+	/*
+	 * Handle the case of an IRQ sent to a stalled oob stage here,
+	 * which allows to trap the same condition in
+	 * dispatch_oob_irq() in a debug check (see comment there).
+	 */
+	oobd = this_oob_staged();
+	if (oob_stage_present() &&
+		irq_settings_is_oob(desc) &&
+		test_stage_bit(STAGE_STALL_BIT, oobd)) {
+		irq_post_stage(&oob_stage, irq);
+	} else {
+		irq_enter_pipeline();
+		handle_oob_irq(desc);
+		irq_exit_pipeline();
+		incr_irq_kstat(desc);
+		synchronize_pipeline_on_irq();
+	}
+
 	hard_local_irq_restore(flags);
 
 	return 0;
-- 
2.16.4

