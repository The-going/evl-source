From 203a167f6816f42dbd2b318ac4240f8e97591749 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Thu, 21 Jul 2016 08:53:52 +0200
Subject: [PATCH] lib/smp_processor_id: irq_pipeline: exclude oob stage from
 preemption check

Code running over the oob stage cannot migrate to another CPU, which
can only happen from the in-band stage. Besides, the oob stage may
have preempted the host kernel in a migration-unsafe section, which
would cause the result of the debug checks to wrongly contradict the
previous rule.

In addition, debug_smp_processor_id() can be called very early during
the boot process when CONFIG_DEBUG_PREEMPT is enabled, so retrieving
the current stage pointer may cause a reference to invalid percpu data
on architectures with late percpu memory fixups of IRQ pipeline
information.

To prevent this, we may check for hard disabled IRQ state first, which
obviously denotes a migration-safe context, and always evaluates to
true during the early boot phase. Then, the current stage is
considered to branch out immediately if running over the oob stage.

Signed-off-by: Philippe Gerum <rpm@xenomai.org>
---
 lib/smp_processor_id.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/lib/smp_processor_id.c b/lib/smp_processor_id.c
index bd9571653288..e6b479d462b9 100644
--- a/lib/smp_processor_id.c
+++ b/lib/smp_processor_id.c
@@ -7,12 +7,16 @@
 #include <linux/export.h>
 #include <linux/kprobes.h>
 #include <linux/sched.h>
+#include <linux/irqstage.h>
 
 notrace static nokprobe_inline
 unsigned int check_preemption_disabled(const char *what1, const char *what2)
 {
 	int this_cpu = raw_smp_processor_id();
 
+	if (hard_irqs_disabled() || !running_inband())
+		goto out;
+
 	if (likely(preempt_count()))
 		goto out;
 
-- 
2.16.4

