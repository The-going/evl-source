From aefe7da5cb2f7b851f7b1ea1327b1dc69ad007b4 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Sun, 19 Feb 2017 12:24:31 +0100
Subject: [PATCH] mm: dovetail: catch might_fault() calls from atomic oob
 context

Making access to user memory which might fault from the oob stage
while hw IRQs are off is a serious problem. Catch any attempt from the
__might_fault() helper.
---
 mm/memory.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/mm/memory.c b/mm/memory.c
index 08336031162e..298594747eed 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -4434,6 +4434,15 @@ void print_vma_addr(char *prefix, unsigned long ip)
 #if defined(CONFIG_PROVE_LOCKING) || defined(CONFIG_DEBUG_ATOMIC_SLEEP)
 void __might_fault(const char *file, int line)
 {
+	/*
+	 * When running over the oob stage (e.g. some co-kernel's own
+	 * thread), we should only make sure to run with hw IRQs
+	 * enabled before accessing the memory.
+	 */
+	if (running_oob()) {
+		WARN_ON_ONCE(hard_irqs_disabled());
+		return;
+	}
 	/*
 	 * Some code (nfs/sunrpc) uses socket ops on kernel memory while
 	 * holding the mmap_sem, this is safe because kernel memory doesn't
-- 
2.16.4

