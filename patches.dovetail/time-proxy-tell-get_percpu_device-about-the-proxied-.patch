From fce72e606043f33edf2f62f6b5c11a44b1f8c8a6 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Thu, 2 May 2019 21:48:13 +0200
Subject: [PATCH] time: proxy: tell get_percpu_device() about the proxied
 device

We need to pass the address of the proxied real device to
get_percpu_device(), so that any prep work which may depend on the
characteristics of that device can be done in the user code.
---
 include/linux/tick.h        |  5 +++--
 kernel/irq/irqptorture.c    |  3 ++-
 kernel/time/clockevents.c   | 28 ++++++++++++++++++------
 kernel/time/tick-internal.h |  6 ++++--
 kernel/time/tick-proxy.c    | 52 ++++++++++++++++++++-------------------------
 5 files changed, 53 insertions(+), 41 deletions(-)

diff --git a/include/linux/tick.h b/include/linux/tick.h
index a5c4d698107d..d9a7d3217d2a 100644
--- a/include/linux/tick.h
+++ b/include/linux/tick.h
@@ -22,8 +22,9 @@ extern void tick_handover_do_timer(void);
 extern void tick_cleanup_dead_cpu(int cpu);
 
 #ifdef CONFIG_IRQ_PIPELINE
-int tick_install_proxy(struct clock_proxy_device *(*get_percpu_device)(void),
-		       const struct cpumask *cpumask);
+int tick_install_proxy(struct clock_proxy_device *(*get_percpu_device)
+		(struct clock_event_device *real_dev),
+		const struct cpumask *cpumask);
 void tick_uninstall_proxy(const struct cpumask *cpumask);
 void tick_notify_proxy(void);
 #endif
diff --git a/kernel/irq/irqptorture.c b/kernel/irq/irqptorture.c
index 1cf099709914..6171cb26c2b4 100644
--- a/kernel/irq/irqptorture.c
+++ b/kernel/irq/irqptorture.c
@@ -32,7 +32,8 @@ static void torture_event_handler(struct clock_event_device *dev)
 	tick_notify_proxy();
 }
 
-static struct clock_proxy_device *get_percpu_device(void)
+static struct clock_proxy_device *
+get_percpu_device(struct clock_event_device *real_dev)
 {
 	struct clock_proxy_device *dev = raw_cpu_ptr(&torture_tick_device);
 
diff --git a/kernel/time/clockevents.c b/kernel/time/clockevents.c
index 6697eecb69df..3b9af41e1eec 100644
--- a/kernel/time/clockevents.c
+++ b/kernel/time/clockevents.c
@@ -444,23 +444,37 @@ EXPORT_SYMBOL_GPL(clockevents_unbind_device);
  * clockevents_register_proxy - register a proxy device on the current CPU
  * @dev:	proxy to register
  */
-int clockevents_register_proxy(struct clock_proxy_device *dev)
+struct clock_proxy_device *clockevents_register_proxy(struct clock_proxy_device *
+			get_percpu_device(struct clock_event_device *real_dev))
 {
 	struct clock_event_device *proxy_dev, *real_dev;
+	struct clock_proxy_device *dev;
 	unsigned long flags;
 	u32 freq;
 
 	raw_spin_lock_irqsave(&clockevents_lock, flags);
 
-	proxy_dev = &dev->proxy_device;
-	clockevent_set_state(proxy_dev, CLOCK_EVT_STATE_DETACHED);
+	real_dev = raw_cpu_ptr(&tick_cpu_device)->evtdev;
+	if ((real_dev->features &
+			(CLOCK_EVT_FEAT_PIPELINE|CLOCK_EVT_FEAT_ONESHOT))
+		!= (CLOCK_EVT_FEAT_PIPELINE|CLOCK_EVT_FEAT_ONESHOT)) {
+		raw_spin_unlock_irqrestore(&clockevents_lock, flags);
+		WARN(1, "cannot use clockevent device %s in proxy mode!",
+			real_dev->name);
+		return ERR_PTR(-ENODEV);
+	}
 
-	real_dev = tick_setup_proxy(dev);
-	if (real_dev == NULL) {
+	dev = get_percpu_device(real_dev);
+	if (IS_ERR(dev)) {
 		raw_spin_unlock_irqrestore(&clockevents_lock, flags);
-		return -ENODEV;
+		return dev;
 	}
 
+	dev->real_device = real_dev;
+	proxy_dev = &dev->proxy_device;
+	clockevent_set_state(proxy_dev, CLOCK_EVT_STATE_DETACHED);
+	tick_setup_proxy(dev);
+
 	list_add(&proxy_dev->list, &clockevent_devices);
 	tick_check_new_device(proxy_dev);
 	clockevents_notify_released();
@@ -471,7 +485,7 @@ int clockevents_register_proxy(struct clock_proxy_device *dev)
 	printk(KERN_INFO "CPU%d: proxy tick device registered (%u.%02uMHz)\n",
 		 smp_processor_id(), freq / 1000000, (freq / 10000) % 100);
 
-	return 0;
+	return dev;
 }
 
 void clockevents_unregister_proxy(struct clock_proxy_device *dev)
diff --git a/kernel/time/tick-internal.h b/kernel/time/tick-internal.h
index feb08956b27f..140e62f10a1a 100644
--- a/kernel/time/tick-internal.h
+++ b/kernel/time/tick-internal.h
@@ -56,8 +56,10 @@ extern int clockevents_program_event(struct clock_event_device *dev,
 extern void clockevents_handle_noop(struct clock_event_device *dev);
 extern int __clockevents_update_freq(struct clock_event_device *dev, u32 freq);
 #ifdef CONFIG_IRQ_PIPELINE
-extern struct clock_event_device *tick_setup_proxy(struct clock_proxy_device *dev);
-extern int clockevents_register_proxy(struct clock_proxy_device *dev);
+void tick_setup_proxy(struct clock_proxy_device *dev);
+extern struct clock_proxy_device *
+clockevents_register_proxy(struct clock_proxy_device *
+			get_percpu_device(struct clock_event_device *real_dev));
 extern void clockevents_unregister_proxy(struct clock_proxy_device *dev);
 #endif
 extern ssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt);
diff --git a/kernel/time/tick-proxy.c b/kernel/time/tick-proxy.c
index 3216d06a371b..f7fdb45bf49e 100644
--- a/kernel/time/tick-proxy.c
+++ b/kernel/time/tick-proxy.c
@@ -8,6 +8,7 @@
 #include <linux/printk.h>
 #include <linux/delay.h>
 #include <linux/smp.h>
+#include <linux/err.h>
 #include <linux/cpumask.h>
 #include <linux/clockchips.h>
 #include <linux/interrupt.h>
@@ -183,11 +184,11 @@ static irqreturn_t proxy_irq_handler(int sirq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-#define interpose_proxy_handler(__dev, __real, __h)		\
+#define interpose_proxy_handler(__proxy, __real, __h)		\
 	do {							\
-		if ((__dev)->__h == NULL) {			\
+		if ((__proxy)->__h == NULL) {			\
 			if ((__real)->__h)			\
-				(__dev)->__h = proxy_ ## __h;	\
+				(__proxy)->__h = proxy_ ## __h;	\
 		}						\
 	} while (0)
 
@@ -196,27 +197,18 @@ static irqreturn_t proxy_irq_handler(int sirq, void *dev_id)
  * current CPU. Called with clockevents_lock held so that the tick
  * device does not change under our feet.
  */
-struct clock_event_device *tick_setup_proxy(struct clock_proxy_device *dev)
+void tick_setup_proxy(struct clock_proxy_device *dev)
 {
 	struct clock_event_device *proxy_dev, *real_dev;
 
-	real_dev = raw_cpu_ptr(&tick_cpu_device)->evtdev;
-	if ((real_dev->features &
-			(CLOCK_EVT_FEAT_PIPELINE|CLOCK_EVT_FEAT_ONESHOT))
-		!= (CLOCK_EVT_FEAT_PIPELINE|CLOCK_EVT_FEAT_ONESHOT)) {
-		WARN(1, "cannot use clockevent device %s in proxy mode!",
-			real_dev->name);
-		return NULL;
-	}
-
 	/*
 	 * The assumption is that clockevents_register_proxy() cannot
 	 * fail afterwards, so this is ok to advertise the new proxy
 	 * in proxy_tick_device.
 	 */
 	__this_cpu_write(proxy_tick_device, dev);
+	real_dev = dev->real_device;
 	dev->handle_inband_event = real_dev->event_handler;
-	dev->real_device = real_dev;
 
 	/*
 	 * Inherit the feature bits since the proxy device has the
@@ -232,10 +224,13 @@ struct clock_event_device *tick_setup_proxy(struct clock_proxy_device *dev)
 	proxy_dev->rating = real_dev->rating + 1;
 	proxy_dev->mult = real_dev->mult;
 	proxy_dev->shift = real_dev->shift;
-	proxy_dev->max_delta_ticks = real_dev->max_delta_ticks;
-	proxy_dev->min_delta_ticks = real_dev->min_delta_ticks;
-	proxy_dev->max_delta_ns = real_dev->max_delta_ns;
-	proxy_dev->min_delta_ns = real_dev->min_delta_ns;
+
+	if (!(proxy_dev->features & CLOCK_EVT_FEAT_KTIME)) {
+		proxy_dev->max_delta_ticks = real_dev->max_delta_ticks;
+		proxy_dev->min_delta_ticks = real_dev->min_delta_ticks;
+		proxy_dev->max_delta_ns = real_dev->max_delta_ns;
+		proxy_dev->min_delta_ns = real_dev->min_delta_ns;
+	}
 
 	/*
 	 * Interpose default handlers which are safe wrt preemption by
@@ -250,8 +245,6 @@ struct clock_event_device *tick_setup_proxy(struct clock_proxy_device *dev)
 	interpose_proxy_handler(proxy_dev, real_dev, tick_resume);
 	interpose_proxy_handler(proxy_dev, real_dev, set_next_event);
 	interpose_proxy_handler(proxy_dev, real_dev, set_next_ktime);
-
-	return real_dev;
 }
 
 static int enable_oob_timer(void *arg) /* hard_irqs_disabled() */
@@ -281,27 +274,28 @@ static int enable_oob_timer(void *arg) /* hard_irqs_disabled() */
 }
 
 struct proxy_install_arg {
-	struct clock_proxy_device *(*get_device)(void);
+	struct clock_proxy_device *(*get_percpu_device)
+	(struct clock_event_device *real_dev);
 	int result;
 };
 
 static void register_proxy_device(void *arg) /* irqs_disabled() */
 {
 	struct proxy_install_arg *req = arg;
-	struct clock_proxy_device *dev = req->get_device();
-	int ret;
+	struct clock_proxy_device *dev;
 
-	ret = clockevents_register_proxy(dev);
-	if (ret) {
+	dev = clockevents_register_proxy(req->get_percpu_device);
+	if (IS_ERR(dev)) {
 		if (!req->result)
-			req->result = ret;
+			req->result = PTR_ERR(dev);
 	} else {
 		dev->real_device->event_handler = proxy_event_handler;
 	}
 }
 
-int tick_install_proxy(struct clock_proxy_device *(*get_percpu_device)(void),
-		       const struct cpumask *cpumask)
+int tick_install_proxy(struct clock_proxy_device *
+		(*get_percpu_device)(struct clock_event_device *real_dev),
+		const struct cpumask *cpumask)
 {
 	struct proxy_install_arg arg;
 	int ret, sirq;
@@ -376,7 +370,7 @@ int tick_install_proxy(struct clock_proxy_device *(*get_percpu_device)(void),
 	 *            clockevents_handle_event(proxy_dev)
 	 *                handle_inband_event(proxy_dev)
 	 */
-	arg.get_device = get_percpu_device;
+	arg.get_percpu_device = get_percpu_device;
 	arg.result = 0;
 	on_each_cpu_mask(cpumask, register_proxy_device, &arg, true);
 	if (arg.result) {
-- 
2.16.4

