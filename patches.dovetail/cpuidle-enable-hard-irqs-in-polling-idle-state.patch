From 9e59cc1d3cf3a38270ccdb9083c029adf0034c1b Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Thu, 9 May 2019 14:33:30 +0200
Subject: [PATCH] cpuidle: enable hard irqs in polling idle state

Signed-off-by: Philippe Gerum <rpm@xenomai.org>
---
 drivers/cpuidle/cpuidle.c    | 4 +++-
 drivers/cpuidle/poll_state.c | 2 +-
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/drivers/cpuidle/cpuidle.c b/drivers/cpuidle/cpuidle.c
index 4171580df8b8..23a2904bfae3 100644
--- a/drivers/cpuidle/cpuidle.c
+++ b/drivers/cpuidle/cpuidle.c
@@ -212,7 +212,9 @@ int cpuidle_enter_state(struct cpuidle_device *dev, struct cpuidle_driver *drv,
 	 * default idle routine instead. If the co-kernel cannot bear
 	 * with the latency induced by the default idling operation,
 	 * then CPUIDLE is not usable and should be disabled at build
-	 * time.
+	 * time. The inband stage is stalled on entry,
+	 * irq_cpuidle_enter() additionally returns with hard irqs
+	 * off.
 	 */
 	if (!irq_cpuidle_enter(dev, target_state)) {
 		default_idle_call();
diff --git a/drivers/cpuidle/poll_state.c b/drivers/cpuidle/poll_state.c
index f7e83613ae94..1245138d7083 100644
--- a/drivers/cpuidle/poll_state.c
+++ b/drivers/cpuidle/poll_state.c
@@ -17,7 +17,7 @@ static int __cpuidle poll_idle(struct cpuidle_device *dev,
 
 	dev->poll_time_limit = false;
 
-	local_irq_enable();
+	local_irq_enable_full();
 	if (!current_set_polling_and_test()) {
 		unsigned int loop_count = 0;
 		u64 limit;
-- 
2.16.4

