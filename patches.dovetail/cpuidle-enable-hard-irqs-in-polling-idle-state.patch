From 437103230dd2a5f363f43b2c62bdd6efe230ef8c Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Thu, 9 May 2019 14:33:30 +0200
Subject: [PATCH] cpuidle: enable hard irqs in polling idle state

---
 drivers/cpuidle/cpuidle.c    | 4 +++-
 drivers/cpuidle/poll_state.c | 2 +-
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/drivers/cpuidle/cpuidle.c b/drivers/cpuidle/cpuidle.c
index 3e2319f5b06c..fd7059f84597 100644
--- a/drivers/cpuidle/cpuidle.c
+++ b/drivers/cpuidle/cpuidle.c
@@ -210,7 +210,9 @@ int cpuidle_enter_state(struct cpuidle_device *dev, struct cpuidle_driver *drv,
 	 * default idle routine instead. If the co-kernel cannot bear
 	 * with the latency induced by the default idling operation,
 	 * then CPUIDLE is not usable and should be disabled at build
-	 * time.
+	 * time. The inband stage is stalled on entry,
+	 * irq_cpuidle_enter() additionally returns with hard irqs
+	 * off.
 	 */
 	if (!irq_cpuidle_enter(dev, target_state)) {
 		default_idle_call();
diff --git a/drivers/cpuidle/poll_state.c b/drivers/cpuidle/poll_state.c
index 02b9315a9e96..e6c9fb84ef55 100644
--- a/drivers/cpuidle/poll_state.c
+++ b/drivers/cpuidle/poll_state.c
@@ -17,7 +17,7 @@ static int __cpuidle poll_idle(struct cpuidle_device *dev,
 
 	dev->poll_time_limit = false;
 
-	local_irq_enable();
+	local_irq_enable_full();
 	if (!current_set_polling_and_test()) {
 		unsigned int loop_count = 0;
 		u64 limit = TICK_NSEC;
-- 
2.16.4

