From 83aac735d6bf1a19027d9c2fafd8d6dc893efded Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Mon, 18 Mar 2019 17:06:50 +0100
Subject: [PATCH] ARM: irq_pipeline: fix interrupt state logic in
 do_work_pending()

Signed-off-by: Philippe Gerum <rpm@xenomai.org>
---
 arch/arm/kernel/signal.c | 42 ++++++++++++++++--------------------------
 1 file changed, 16 insertions(+), 26 deletions(-)

diff --git a/arch/arm/kernel/signal.c b/arch/arm/kernel/signal.c
index 1f2d54bc0ff0..7601879fa841 100644
--- a/arch/arm/kernel/signal.c
+++ b/arch/arm/kernel/signal.c
@@ -8,6 +8,7 @@
 #include <linux/random.h>
 #include <linux/signal.h>
 #include <linux/personality.h>
+#include <linux/irq_pipeline.h>
 #include <linux/uaccess.h>
 #include <linux/tracehook.h>
 #include <linux/uprobes.h>
@@ -642,25 +643,28 @@ static int do_signal(struct pt_regs *regs, int syscall)
 asmlinkage int
 do_work_pending(struct pt_regs *regs, unsigned int thread_flags, int syscall)
 {
-	bool stalled = irqs_disabled();
-	int ret = 0;
-
-	local_irq_disable();
+	WARN_ON_ONCE(irq_pipeline_debug() &&
+		(irqs_disabled() || running_oob()));
 
 	/*
 	 * The assembly code enters us with IRQs off, but it hasn't
 	 * informed the tracing code of that for efficiency reasons.
 	 * Update the trace code with the current status.
 	 */
-	trace_hardirqs_off();
+	if (!irqs_pipelined())
+		trace_hardirqs_off();
 	do {
-		if (likely(thread_flags & _TIF_NEED_RESCHED)) {
+		if (irqs_pipelined()) {
+			local_irq_disable();
 			hard_cond_local_irq_enable();
+		}
+
+		if (likely(thread_flags & _TIF_NEED_RESCHED)) {
 			schedule();
 		} else {
 			if (unlikely(!user_mode(regs)))
-				goto out;
-			local_irq_enable_full();
+				return 0;
+			local_irq_enable();
 			if (thread_flags & _TIF_SIGPENDING) {
 				int restart = do_signal(regs, syscall);
 				if (unlikely(restart)) {
@@ -669,8 +673,7 @@ do_work_pending(struct pt_regs *regs, unsigned int thread_flags, int syscall)
 					 * Deal with it without leaving
 					 * the kernel space.
 					 */
-					ret = restart;
-					goto out;
+					return restart;
 				}
 				syscall = 0;
 			} else if (thread_flags & _TIF_UPROBE) {
@@ -681,23 +684,10 @@ do_work_pending(struct pt_regs *regs, unsigned int thread_flags, int syscall)
 				rseq_handle_notify_resume(NULL, regs);
 			}
 		}
-		local_irq_disable_full();
-		thread_flags = current_thread_info()->flags;
-	} while (thread_flags & _TIF_WORK_MASK);
-
-	hard_cond_local_irq_enable();
-out:
-	if (irqs_pipelined()) {
-		local_irq_enable();
-		if (stalled) {
-			local_irq_disable();
-			if (IS_ENABLED(CONFIG_DEBUG_IRQ_PIPELINE))
-				WARN_ON_ONCE(user_mode(regs));
-		}
 		hard_local_irq_disable();
-	}
-
-	return ret;
+		thread_flags = current_thread_info()->flags;
+	} while (inband_irq_pending() || (thread_flags & _TIF_WORK_MASK));
+	return 0;
 }
 
 struct page *get_signal_page(void)
-- 
2.16.4

