From 07a5b40127ab0c427ab9844b7e8d13f2ff073317 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Sun, 19 May 2019 21:26:11 +0200
Subject: [PATCH] sched: irq_pipeline: leverage IRQ state invariants in
 preempt_schedule_irq()

When interrupt pipelining is enabled, preempt_schedule_irq() must be
called from the inband stage only, with hard IRQs off, inband stage
unstalled. Any other combination would be a clear indication that
something is badly broken at call site.

Since the inband stage must be unstalled on entry, we may use this
invariant to simplify the code reconciling the hardware and virtual
interrupt states across the inband schedule() call.
---
 kernel/sched/core.c | 22 +++++++++++++---------
 1 file changed, 13 insertions(+), 9 deletions(-)

diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index f0338c76ebc1..5c4e9337b065 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -4335,7 +4335,7 @@ EXPORT_SYMBOL_GPL(preempt_schedule_notrace);
 #endif /* CONFIG_PREEMPTION */
 
 #ifdef CONFIG_IRQ_PIPELINE
-static inline void preempt_sync_inband_irqs(unsigned long flags)
+static inline void preempt_sync_inband_irqs(void)
 {
 	struct irq_stage_data *p;
 
@@ -4347,12 +4347,13 @@ static inline void preempt_sync_inband_irqs(unsigned long flags)
 		clear_stage_bit(STAGE_STALL_BIT, p);
 		sync_current_stage();
 		preempt_enable_no_resched_notrace();
-	}
-	/* We leave IRQs hard disabled. */
-	inband_irq_restore_nosync(flags);
+	} else
+		clear_stage_bit(STAGE_STALL_BIT, p);
+
+	/* hard IRQs are left disabled. */
 }
 #else
-static inline void preempt_sync_inband_irqs(unsigned long flags) { }
+static inline void preempt_sync_inband_irqs(void) { }
 #endif
 
 /*
@@ -4364,11 +4365,14 @@ static inline void preempt_sync_inband_irqs(unsigned long flags) { }
 asmlinkage __visible void __sched preempt_schedule_irq(void)
 {
 	enum ctx_state prev_state;
-	unsigned long flags;
 
 	if (irqs_pipelined()) {
-		WARN_ON_ONCE(!hard_irqs_disabled());
-		local_irq_save(flags);
+		if (irq_pipeline_debug()) {
+			WARN_ON_ONCE(!running_inband());
+			WARN_ON_ONCE(!hard_irqs_disabled());
+			WARN_ON_ONCE(irqs_disabled());
+		}
+		local_irq_disable();
 		hard_local_irq_enable();
 	}
 
@@ -4392,7 +4396,7 @@ asmlinkage __visible void __sched preempt_schedule_irq(void)
 	 * need_resched is clear, so we just need to synchronize the
 	 * in-band stage log.
 	 */
-	preempt_sync_inband_irqs(flags);
+	preempt_sync_inband_irqs();
 
 	exception_exit(prev_state);
 }
-- 
2.16.4

