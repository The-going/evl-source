From 61544107edb767f6110c4080ede05064bd6687fc Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Sun, 19 May 2019 21:26:11 +0200
Subject: [PATCH] sched: irq_pipeline: leverage IRQ state invariants in
 preempt_schedule_irq()

When interrupt pipelining is enabled, preempt_schedule_irq() must be
called from the inband stage only, with hard IRQs off, inband stage
unstalled. Any other combination would be a clear indication that
something is badly broken at call site.

Since the inband stage must be unstalled on entry, we may use this
invariant to simplify the code reconciling the hardware and virtual
interrupt states across the inband schedule() call.
---
 kernel/sched/core.c | 22 +++++++++++++---------
 1 file changed, 13 insertions(+), 9 deletions(-)

diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 0fb8c84b206b..cc169d714964 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -4326,7 +4326,7 @@ EXPORT_SYMBOL_GPL(preempt_schedule_notrace);
 #endif /* CONFIG_PREEMPTION */
 
 #ifdef CONFIG_IRQ_PIPELINE
-static inline void preempt_sync_inband_irqs(unsigned long flags)
+static inline void preempt_sync_inband_irqs(void)
 {
 	struct irq_stage_data *p;
 
@@ -4338,12 +4338,13 @@ static inline void preempt_sync_inband_irqs(unsigned long flags)
 		clear_stage_bit(STAGE_STALL_BIT, p);
 		sync_current_stage();
 		preempt_enable_no_resched_notrace();
-	}
-	/* We leave IRQs hard disabled. */
-	inband_irq_restore_nosync(flags);
+	} else
+		clear_stage_bit(STAGE_STALL_BIT, p);
+
+	/* hard IRQs are left disabled. */
 }
 #else
-static inline void preempt_sync_inband_irqs(unsigned long flags) { }
+static inline void preempt_sync_inband_irqs(void) { }
 #endif
 
 /*
@@ -4355,11 +4356,14 @@ static inline void preempt_sync_inband_irqs(unsigned long flags) { }
 asmlinkage __visible void __sched preempt_schedule_irq(void)
 {
 	enum ctx_state prev_state;
-	unsigned long flags;
 
 	if (irqs_pipelined()) {
-		WARN_ON_ONCE(!hard_irqs_disabled());
-		local_irq_save(flags);
+		if (irq_pipeline_debug()) {
+			WARN_ON_ONCE(!running_inband());
+			WARN_ON_ONCE(!hard_irqs_disabled());
+			WARN_ON_ONCE(irqs_disabled());
+		}
+		local_irq_disable();
 		hard_local_irq_enable();
 	}
 
@@ -4383,7 +4387,7 @@ asmlinkage __visible void __sched preempt_schedule_irq(void)
 	 * need_resched is clear, so we just need to synchronize the
 	 * in-band stage log.
 	 */
-	preempt_sync_inband_irqs(flags);
+	preempt_sync_inband_irqs();
 
 	exception_exit(prev_state);
 }
-- 
2.16.4

