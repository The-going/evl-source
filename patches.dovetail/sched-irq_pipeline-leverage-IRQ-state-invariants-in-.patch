From 684a1325d18a266b0d33b70a1d4ad572bd8453b9 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Sun, 19 May 2019 21:26:11 +0200
Subject: [PATCH] sched: irq_pipeline: leverage IRQ state invariants in
 preempt_schedule_irq()

When interrupt pipelining is enabled, preempt_schedule_irq() must be
called from the inband stage only, with hard IRQs off, inband stage
unstalled. Any other combination would be a clear indication that
something is badly broken at call site.

Since the inband stage must be unstalled on entry, we may use this
invariant to simplify the code reconciling the hardware and virtual
interrupt states across the inband schedule() call.

Signed-off-by: Philippe Gerum <rpm@xenomai.org>
---
 kernel/sched/core.c | 22 +++++++++++++---------
 1 file changed, 13 insertions(+), 9 deletions(-)

diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 0c3d4f856b30..1e98bd57fce0 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -4345,7 +4345,7 @@ EXPORT_SYMBOL_GPL(preempt_schedule_notrace);
 #endif /* CONFIG_PREEMPTION */
 
 #ifdef CONFIG_IRQ_PIPELINE
-static inline void preempt_sync_inband_irqs(unsigned long flags)
+static inline void preempt_sync_inband_irqs(void)
 {
 	struct irq_stage_data *p;
 
@@ -4357,12 +4357,13 @@ static inline void preempt_sync_inband_irqs(unsigned long flags)
 		clear_stage_bit(STAGE_STALL_BIT, p);
 		sync_current_stage();
 		preempt_enable_no_resched_notrace();
-	}
-	/* We leave IRQs hard disabled. */
-	inband_irq_restore_nosync(flags);
+	} else
+		clear_stage_bit(STAGE_STALL_BIT, p);
+
+	/* hard IRQs are left disabled. */
 }
 #else
-static inline void preempt_sync_inband_irqs(unsigned long flags) { }
+static inline void preempt_sync_inband_irqs(void) { }
 #endif
 
 /*
@@ -4374,11 +4375,14 @@ static inline void preempt_sync_inband_irqs(unsigned long flags) { }
 asmlinkage __visible void __sched preempt_schedule_irq(void)
 {
 	enum ctx_state prev_state;
-	unsigned long flags;
 
 	if (irqs_pipelined()) {
-		WARN_ON_ONCE(!hard_irqs_disabled());
-		local_irq_save(flags);
+		if (irq_pipeline_debug()) {
+			WARN_ON_ONCE(!running_inband());
+			WARN_ON_ONCE(!hard_irqs_disabled());
+			WARN_ON_ONCE(irqs_disabled());
+		}
+		local_irq_disable();
 		hard_local_irq_enable();
 	}
 
@@ -4402,7 +4406,7 @@ asmlinkage __visible void __sched preempt_schedule_irq(void)
 	 * need_resched is clear, so we just need to synchronize the
 	 * in-band stage log.
 	 */
-	preempt_sync_inband_irqs(flags);
+	preempt_sync_inband_irqs();
 
 	exception_exit(prev_state);
 }
-- 
2.16.4

