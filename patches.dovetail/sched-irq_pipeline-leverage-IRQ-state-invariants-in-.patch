From 10e2f735f6af097735855f2522a79565f45e21ee Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Sun, 19 May 2019 21:26:11 +0200
Subject: [PATCH] sched: irq_pipeline: leverage IRQ state invariants in
 preempt_schedule_irq()

When interrupt pipelining is enabled, preempt_schedule_irq() must be
called from the inband stage only, with hard IRQs off, inband stage
unstalled. Any other combination would be a clear indication that
something is badly broken at call site.

Since the inband stage must be unstalled on entry, we may use this
invariant to simplify the code reconciling the hardware and virtual
interrupt states across the inband schedule() call.
---
 kernel/sched/core.c | 22 +++++++++++++---------
 1 file changed, 13 insertions(+), 9 deletions(-)

diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index e474ec10a151..136e25a9e7f9 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -3700,7 +3700,7 @@ EXPORT_SYMBOL_GPL(preempt_schedule_notrace);
 #endif /* CONFIG_PREEMPT */
 
 #ifdef CONFIG_IRQ_PIPELINE
-static inline void preempt_sync_inband_irqs(unsigned long flags)
+static inline void preempt_sync_inband_irqs(void)
 {
 	struct irq_stage_data *p;
 
@@ -3712,12 +3712,13 @@ static inline void preempt_sync_inband_irqs(unsigned long flags)
 		clear_stage_bit(STAGE_STALL_BIT, p);
 		sync_current_stage();
 		preempt_enable_no_resched_notrace();
-	}
-	/* We leave IRQs hard disabled. */
-	inband_irq_restore_nosync(flags);
+	} else
+		clear_stage_bit(STAGE_STALL_BIT, p);
+
+	/* hard IRQs are left disabled. */
 }
 #else
-static inline void preempt_sync_inband_irqs(unsigned long flags) { }
+static inline void preempt_sync_inband_irqs(void) { }
 #endif
 
 /*
@@ -3729,11 +3730,14 @@ static inline void preempt_sync_inband_irqs(unsigned long flags) { }
 asmlinkage __visible void __sched preempt_schedule_irq(void)
 {
 	enum ctx_state prev_state;
-	unsigned long flags;
 
 	if (irqs_pipelined()) {
-		WARN_ON_ONCE(!hard_irqs_disabled());
-		local_irq_save(flags);
+		if (irq_pipeline_debug()) {
+			WARN_ON_ONCE(!running_inband());
+			WARN_ON_ONCE(!hard_irqs_disabled());
+			WARN_ON_ONCE(irqs_disabled());
+		}
+		local_irq_disable();
 		hard_local_irq_enable();
 	}
 
@@ -3757,7 +3761,7 @@ asmlinkage __visible void __sched preempt_schedule_irq(void)
 	 * need_resched is clear, so we just need to synchronize the
 	 * in-band stage log.
 	 */
-	preempt_sync_inband_irqs(flags);
+	preempt_sync_inband_irqs();
 
 	exception_exit(prev_state);
 }
-- 
2.16.4

