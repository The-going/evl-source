From b444e850761306c9ab2eccb78c88f6cd80a6df94 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Tue, 28 May 2019 21:08:30 +0200
Subject: [PATCH] genirq: irq_pipeline: fix double-ack in irqflow re-entry

Interrupt pipelining means that IRQ flow handlers may be entered twice
for any IRQ, once for feeding the pipeline with the incoming event, a
second time for running deferred IRQ handlers when the inband
interrupt log is synchronized on any given CPU.

Make sure not to (re-)run any mask_ack() sequence during this second
run, extending this to any operation which only makes sense from the
initial event handling phase (e.g. checking irq_may_run()).

Signed-off-by: Philippe Gerum <rpm@xenomai.org>
---
 include/linux/hardirq.h |  5 ++++
 kernel/irq/chip.c       | 69 ++++++++++++++++++++++++++++---------------------
 2 files changed, 45 insertions(+), 29 deletions(-)

diff --git a/include/linux/hardirq.h b/include/linux/hardirq.h
index ec5757babe95..3350a2bc8a4f 100644
--- a/include/linux/hardirq.h
+++ b/include/linux/hardirq.h
@@ -92,6 +92,11 @@ extern void irq_exit(void);
 		irq_pipeline_nmi_exit();			\
 	} while (0)
 
+static inline bool start_irq_flow(void)
+{
+	return !irqs_pipelined() || in_pipeline();
+}
+
 static inline bool on_pipeline_entry(void)
 {
 	return irqs_pipelined() && in_pipeline();
diff --git a/kernel/irq/chip.c b/kernel/irq/chip.c
index e50ce9deaa5f..e0467ee8ebee 100644
--- a/kernel/irq/chip.c
+++ b/kernel/irq/chip.c
@@ -526,7 +526,8 @@ static bool irq_may_run(struct irq_desc *desc)
 	 *
 	 * - from the in-band context, run the PM wakeup check.
 	 */
-	if (on_pipeline_entry()) {
+	if (irqs_pipelined()) {
+		WARN_ON_ONCE(irq_pipeline_debug() && !in_pipeline());
 		if (irqd_is_wakeup_armed(&desc->irq_data))
 			return true;
 	} else if (irq_pm_check_wakeup(desc))
@@ -553,7 +554,7 @@ void handle_simple_irq(struct irq_desc *desc)
 {
 	raw_spin_lock(&desc->lock);
 
-	if (!irq_may_run(desc))
+	if (start_irq_flow() && !irq_may_run(desc))
 		goto out_unlock;
 
 	if (on_pipeline_entry()) {
@@ -595,7 +596,7 @@ void handle_untracked_irq(struct irq_desc *desc)
 
 	raw_spin_lock(&desc->lock);
 
-	if (!irq_may_run(desc))
+	if (start_irq_flow() && !irq_may_run(desc))
 		goto out_unlock;
 
 	if (on_pipeline_entry()) {
@@ -668,10 +669,13 @@ static void cond_unmask_irq(struct irq_desc *desc)
 void handle_level_irq(struct irq_desc *desc)
 {
 	raw_spin_lock(&desc->lock);
-	mask_ack_irq(desc);
 
-	if (!irq_may_run(desc))
-		goto out_unlock;
+	if (start_irq_flow()) {
+		mask_ack_irq(desc);
+
+		if (!irq_may_run(desc))
+			goto out_unlock;
+	}
 
 	if (on_pipeline_entry()) {
 		if (handle_oob_irq(desc))
@@ -751,7 +755,7 @@ void handle_fasteoi_irq(struct irq_desc *desc)
 
 	raw_spin_lock(&desc->lock);
 
-	if (!irq_may_run(desc))
+	if (start_irq_flow() && !irq_may_run(desc))
 		goto out;
 
 	if (on_pipeline_entry()) {
@@ -846,22 +850,24 @@ void handle_edge_irq(struct irq_desc *desc)
 
 	raw_spin_lock(&desc->lock);
 
-	desc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);
+	if (start_irq_flow()) {
+		desc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);
 
-	if (!irq_may_run(desc)) {
-		desc->istate |= IRQS_PENDING;
-		mask_ack_irq(desc);
-		goto out_unlock;
-	}
+		if (!irq_may_run(desc)) {
+			desc->istate |= IRQS_PENDING;
+			mask_ack_irq(desc);
+			goto out_unlock;
+		}
 
-	/*
-	 * If its disabled or no action available then mask it and get
-	 * out of here.
-	 */
-	if (irqd_irq_disabled(&desc->irq_data) || !desc->action) {
-		desc->istate |= IRQS_PENDING;
-		mask_ack_irq(desc);
-		goto out_unlock;
+		/*
+		 * If its disabled or no action available then mask it
+		 * and get out of here.
+		 */
+		if (irqd_irq_disabled(&desc->irq_data) || !desc->action) {
+			desc->istate |= IRQS_PENDING;
+			mask_ack_irq(desc);
+			goto out_unlock;
+		}
 	}
 
 	if (on_pipeline_entry()) {
@@ -917,11 +923,13 @@ void handle_edge_eoi_irq(struct irq_desc *desc)
 
 	raw_spin_lock(&desc->lock);
 
-	desc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);
+	if (start_irq_flow()) {
+		desc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);
 
-	if (!irq_may_run(desc)) {
-		desc->istate |= IRQS_PENDING;
-		goto out_eoi;
+		if (!irq_may_run(desc)) {
+			desc->istate |= IRQS_PENDING;
+			goto out_eoi;
+		}
 	}
 
 	if (on_pipeline_entry()) {
@@ -1314,7 +1322,7 @@ void handle_fasteoi_ack_irq(struct irq_desc *desc)
 
 	raw_spin_lock(&desc->lock);
 
-	if (!irq_may_run(desc))
+	if (start_irq_flow() && !irq_may_run(desc))
 		goto out;
 
 	if (on_pipeline_entry()) {
@@ -1377,10 +1385,13 @@ void handle_fasteoi_mask_irq(struct irq_desc *desc)
 	struct irq_chip *chip = desc->irq_data.chip;
 
 	raw_spin_lock(&desc->lock);
-	mask_ack_irq(desc);
 
-	if (!irq_may_run(desc))
-		goto out;
+	if (start_irq_flow()) {
+		mask_ack_irq(desc);
+
+		if (!irq_may_run(desc))
+			goto out;
+	}
 
 	if (on_pipeline_entry()) {
 		if (handle_oob_irq(desc))
-- 
2.16.4

